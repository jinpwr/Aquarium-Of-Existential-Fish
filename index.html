<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #9ed3da 0%, #3d69b4 45%, #14063a 100%);
      animation: hueOcean 110s ease-in-out infinite;
    }
    @keyframes hueOcean {
      0%   { background: linear-gradient(to bottom, #9ed3da 0%, #3d69b4 45%, #14063a 100%); }
      50%  { background: linear-gradient(to bottom, #8bbce2 0%, #425dcb 45%, #140a45 100%); }
      100% { background: linear-gradient(to bottom, #9ed3da 0%, #3d69b4 45%, #14063a 100%); }
    }
    canvas { display:block }
    #overlay{
      position:fixed; inset:0; pointer-events:none; z-index:3;
      display:flex; align-items:flex-end; justify-content:flex-end;
      padding:12px 14px;
      font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#b3f4ff; text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{ font-weight:700; letter-spacing:.5px; font-size:12px; color:#9effc7; }
  </style>
</head>
<body>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0e0830, 0.06);
    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);
    const renderer = new THREE.WebGLRenderer({antialias:true,alpha:true,premultipliedAlpha:false});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth,innerHeight);
    renderer.outputColorSpace=THREE.SRGBColorSpace;
    renderer.toneMapping=THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure=1.6;
    document.body.appendChild(renderer.domElement);

    const hemi=new THREE.HemisphereLight(0xbfeaff,0x0f1033,0.7);
    const key =new THREE.PointLight(0x7cd9ff,26,120,1.8); key.position.set(5,4,6);
    const fill=new THREE.PointLight(0x6ff0d4,10,120,1.8); fill.position.set(-5,1.2,5);
    const rim =new THREE.PointLight(0x6b6bff,16,160,2.2); rim.position.set(0,3.6,-9);
    scene.add(hemi,key,fill,rim);

    const rand=(a,b)=>a+Math.random()*(b-a);
    const choose=a=>a[(Math.random()*a.length)|0];

    const raycaster=new THREE.Raycaster();
    const mouseNDC=new THREE.Vector2();
    const plane=new THREE.Plane(new THREE.Vector3(0,0,1),0);
    const mouseWorld=new THREE.Vector3(999,999,0);
    let mouseX=0; const panRange=1.4;
    addEventListener('mousemove',e=>{
      mouseX=(e.clientX/innerWidth)*2-1;
      mouseNDC.x=mouseX; mouseNDC.y=-(e.clientY/innerHeight)*2+1;
      raycaster.setFromCamera(mouseNDC,camera);
      raycaster.ray.intersectPlane(plane,mouseWorld);
    });

    const PHRASES=['i am not real','today i forgot myself','be kind to the void','do fish dream?','404: meaning not found','blink slowly','pretend to be water','becoming â€¦ becoming','a small thought floats'];
    function makeBubbleSprite(text){
      const w=256,h=128;const c=document.createElement('canvas');c.width=w;c.height=h;
      const x=c.getContext('2d');
      x.fillStyle='rgba(0,0,0,0.35)';
      x.strokeStyle='rgba(255,255,255,0.85)';x.lineWidth=3;
      x.beginPath();x.moveTo(14,8);x.arcTo(w-8,8,w-8,h-8,14);x.arcTo(w-8,h-8,8,h-8,14);
      x.arcTo(8,h-8,8,8,14);x.arcTo(8,8,w-8,8,14);x.closePath();x.fill();x.stroke();
      x.font='600 22px ui-monospace, monospace';x.fillStyle='rgba(235,255,250,0.98)';
      x.textAlign='center';x.textBaseline='middle';x.fillText(text,w/2,h/2);
      const tex=new THREE.CanvasTexture(c);
      const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false});
      const s=new THREE.Sprite(mat);s.scale.set(2.2,1.1,1);
      s.userData={ctx:x,texture:tex};
      return s;
    }

    function updateBubbleText(s,t){
      const {ctx,texture}=s.userData;const w=256,h=128;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle='rgba(0,0,0,0.35)';
      ctx.strokeStyle='rgba(255,255,255,0.85)';ctx.lineWidth=3;
      ctx.beginPath();ctx.moveTo(14,8);ctx.arcTo(w-8,8,w-8,h-8,14);
      ctx.arcTo(w-8,h-8,8,h-8,14);ctx.arcTo(8,h-8,8,8,14);ctx.arcTo(8,8,w-8,8,14);
      ctx.closePath();ctx.fill();ctx.stroke();
      ctx.font='600 22px ui-monospace, monospace';ctx.fillStyle='rgba(235,255,250,0.98)';
      ctx.textAlign='center';ctx.textBaseline='middle';ctx.fillText(t,w/2,h/2);
      texture.needsUpdate=true;
    }

    // distinct hues around color wheel
    const BASES=[];
    for(let i=0;i<18;i++){const col=new THREE.Color().setHSL(i/18,0.85,0.55);BASES.push(`#${col.getHexString()}`);}

    function canvasFishTexture(seed){
      const w=512,h=256;const c=document.createElement('canvas');c.width=w;c.height=h;
      const g=c.getContext('2d');
      const base=new THREE.Color(seed);
      const belly=base.clone().lerp(new THREE.Color('#fff'),0.55);
      const back =base.clone().lerp(new THREE.Color('#000'),0.35);
      const grd=g.createLinearGradient(0,0,0,h);
      grd.addColorStop(0,`#${belly.getHexString()}`);
      grd.addColorStop(0.5,`#${base.getHexString()}`);
      grd.addColorStop(1,`#${back.getHexString()}`);
      g.fillStyle=grd;g.fillRect(0,0,w,h);

      g.globalAlpha=0.35;
      for(let x=0;x<w;x+=14){
        const fade=(Math.sin(x*0.07)+1)/2*0.8+0.2;
        g.fillStyle=`rgba(255,255,255,${fade*0.4})`;
        g.fillRect(x,0,6,h);
      }
      g.globalAlpha=1;
      for(let i=0;i<2000;i++){
        const xx=Math.random()*w,yy=Math.random()*h;
        g.fillStyle=`rgba(255,255,255,${Math.random()*0.25})`;
        g.beginPath();g.arc(xx,yy,Math.random()*1.5,0,Math.PI*2);g.fill();
      }
      g.strokeStyle='rgba(255,255,255,0.45)';g.lineWidth=2;
      g.beginPath();
      for(let x=0;x<w;x+=10){g.lineTo(x,h*0.55+Math.sin(x*0.05)*2);}
      g.stroke();

      const tex=new THREE.CanvasTexture(c);
      tex.anisotropy=renderer.capabilities.getMaxAnisotropy();
      return tex;
    }

    function makeMat(seed){
      return new THREE.MeshStandardMaterial({
        map:canvasFishTexture(seed),
        color:0xffffff,
        roughness:0.3,
        metalness:0.3,
        emissive:new THREE.Color(0x1a1a1a),
        emissiveIntensity:0.3,
        transparent:true
      });
    }

    const BOUNDS={x:5.8,y:2.9,z:3.8};
    class Fish{
      constructor(color){
        this.group=new THREE.Group();
        const body=new THREE.Mesh(new THREE.IcosahedronGeometry(rand(0.25,0.38),0),makeMat(color));
        body.scale.set(rand(1.6,2.1),1,1);
        this.group.add(body);
        this.bodyMesh=body;
        this.bubble=makeBubbleSprite(choose(PHRASES));
        this.bubble.position.set(0,0.9,0);
        this.group.add(this.bubble);
        this.group.position.set(rand(-4,4),rand(-1.2,2.2),rand(-2.5,2.5));
        this.vel=new THREE.Vector3(rand(-0.02,0.02),rand(-0.01,0.01),rand(-0.015,0.015));
        this.speed=rand(0.004,0.018);
        this.dead=false;
        scene.add(this.group);
      }
      fadeAway(){
        if(this.dead) return;
        this.dead=true;
        const sprite=makeBubbleSprite("i will remember this.");
        sprite.position.copy(this.group.position).add(new THREE.Vector3(0,0.8,0));
        scene.add(sprite);
        const start=performance.now();
        const animateFade=()=>{
          const t=(performance.now()-start)/1500;
          this.group.traverse(o=>{if(o.material) o.material.opacity=Math.max(0,1-t);});
          if(t<1) requestAnimationFrame(animateFade);
          else scene.remove(this.group);
        };
        animateFade();
        const bubbleStart=performance.now();
        const bubbleAnim=()=>{
          const t=(performance.now()-bubbleStart)/4000;
          sprite.position.y+=0.002;
          sprite.material.opacity=1-t;
          if(t<1) requestAnimationFrame(bubbleAnim);
          else scene.remove(sprite);
        };
        bubbleAnim();
      }
      update(dt){
        if(this.dead) return;
        this.group.position.addScaledVector(this.vel,dt*60);
        const p=this.group.position;
        if(p.x<-BOUNDS.x||p.x>BOUNDS.x) this.vel.x*=-1;
        if(p.y<-BOUNDS.y||p.y>BOUNDS.y) this.vel.y*=-1;
        if(p.z<-BOUNDS.z||p.z>BOUNDS.z) this.vel.z*=-1;
        this.bubble.lookAt(camera.position);
      }
    }

    const FISH=[];for(let i=0;i<18;i++)FISH.push(new Fish(BASES[i%BASES.length]));
    setInterval(()=>{const f=FISH[(Math.random()*FISH.length)|0];if(!f.dead)updateBubbleText(f.bubble,choose(PHRASES));},2200);

    addEventListener('click',e=>{
      mouseNDC.x=(e.clientX/innerWidth)*2-1;
      mouseNDC.y=-(e.clientY/innerHeight)*2+1;
      raycaster.setFromCamera(mouseNDC,camera);
      const intersects=raycaster.intersectObjects(FISH.map(f=>f.bodyMesh));
      if(intersects.length>0){
        const f=FISH.find(ff=>ff.bodyMesh===intersects[0].object);
        if(f) f.fadeAway();
      }
    });

    const bubbleGeo=new THREE.BufferGeometry();
    const bubbleCount=220,pos=new Float32Array(bubbleCount*3),speed=new Float32Array(bubbleCount);
    for(let i=0;i<bubbleCount;i++){pos[i*3]=rand(-6,6);pos[i*3+1]=rand(-3,3);pos[i*3+2]=rand(-4,4);speed[i]=rand(0.12,0.45);}
    bubbleGeo.setAttribute('position',new THREE.BufferAttribute(pos,3));
    const bubbleMat=new THREE.PointsMaterial({color:0xdff9ff,size:0.06,transparent:true,opacity:0.7,depthWrite:false,blending:THREE.AdditiveBlending});
    const bubbles=new THREE.Points(bubbleGeo,bubbleMat);scene.add(bubbles);
    function updateBubbles(dt){const a=bubbleGeo.attributes.position.array;for(let i=0;i<bubbleCount;i++){let x=a[i*3],y=a[i*3+1],z=a[i*3+2];y+=speed[i]*dt;if(y>3.2){y=-3.2;x=rand(-6,6);z=rand(-4,4);}a[i*3]=x;a[i*3+1]=y;a[i*3+2]=z;}bubbleGeo.attributes.position.needsUpdate=true;}

    const SHARK_SRC='shark.png';
    class Shark{constructor(){this.dir=1;this.speed=0.55;this.y=rand(0.2,1.2);this.z=-7.8;this.phase=Math.random()*Math.PI*2;this.flipBound=16.5;
      new THREE.TextureLoader().load(SHARK_SRC,t=>{t.colorSpace=THREE.SRGBColorSpace;t.premultiplyAlpha=true;
        const aspect=t.image.width/t.image.height,W=19,H=W/aspect;
        const m=new THREE.MeshBasicMaterial({map:t,transparent:true,opacity:0.75,depthWrite:false,side:THREE.DoubleSide,alphaTest:0.03});
        this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(W,H),m);this.mesh.position.set(-this.flipBound-0.2,this.y,this.z);scene.add(this.mesh);});
    }update(dt,t){if(!this.mesh)return;this.mesh.position.x+=this.dir*this.speed*dt;this.mesh.position.y=this.y+Math.sin(t*0.25+this.phase)*0.12;
      if(this.dir>0&&this.mesh.position.x>this.flipBound){this.dir=-1;this.mesh.rotation.y=Math.PI;}
      else if(this.dir<0&&this.mesh.position.x<-this.flipBound){this.dir=1;this.mesh.rotation.y=0;}}}
    const SHARK=new Shark();

    addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});

    let last=performance.now();
    function tick(now){
      const dt=Math.min((now-last)/1000,0.05);last=now;const t=now*0.001;
      const targetX=mouseX*panRange;camera.position.x+=(targetX-camera.position.x)*0.05;camera.lookAt(0,0,0);
      for(const f of FISH)f.update(dt);
      updateBubbles(dt);SHARK.update(dt,t);
      renderer.render(scene,camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
