<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish — Iridescent Shader</title>
  <style>
    html,body{
      height:100%; margin:0; overflow:hidden;
      /* Lighter top → darker bottom; only cool spectrum; smooth hue drift with no jumps */
      background: linear-gradient(to bottom, #75c6e6 0%, #365eb6 45%, #14063d 100%);
      animation: hueDrift 160s linear infinite alternate;
    }
    @keyframes hueDrift{
      0%   { filter: hue-rotate(0deg); }
      50%  { filter: hue-rotate(45deg); }
      100% { filter: hue-rotate(90deg); }
    }
    canvas{ display:block }
    #overlay{
      position:fixed; inset:0; pointer-events:none; z-index:3;
      display:flex; align-items:flex-end; justify-content:flex-end;
      padding:12px 14px;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      color:#b3f4ff; text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{ font-weight:700; letter-spacing:.5px; font-size:12px; color:#9effc7; }
  </style>
</head>
<body>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /* ===== Scene / Renderer / Camera ===== */
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0e0830, 0.06);

    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.6;
    document.body.appendChild(renderer.domElement);

    /* ===== Lights (cool blue) ===== */
    const hemi = new THREE.HemisphereLight(0xbfeaff, 0x0f1033, 0.7);
    const key  = new THREE.PointLight(0x7cd9ff, 26, 120, 1.8); key.position.set(5, 4, 6);
    const fill = new THREE.PointLight(0x6ff0d4, 10, 120, 1.8); fill.position.set(-5, 1.2, 5);
    const rim  = new THREE.PointLight(0x6b6bff, 16, 160, 2.2); rim.position.set(0, 3.6, -9);
    scene.add(hemi, key, fill, rim);

    /* ===== Utils ===== */
    const rand = (a,b) => a + Math.random()*(b-a);
    const choose = a => a[(Math.random()*a.length)|0];
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    function lerpAngle(a, b, t){ let d=(b-a+Math.PI)%(2*Math.PI)-Math.PI; return a + d*t; }

    /* ===== Mouse: world projection + horizontal pan + subtle avoidance ===== */
    const raycaster = new THREE.Raycaster();
    const mouseNDC = new THREE.Vector2();
    const plane    = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
    const mouseWorld = new THREE.Vector3(999,999,0); // far away initially
    let mouseX = 0;
    const panRange = 1.2;

    addEventListener('mousemove', e=>{
      mouseX = (e.clientX/innerWidth)*2 - 1;
      mouseNDC.x = mouseX;
      mouseNDC.y = -(e.clientY/innerHeight)*2 + 1;
      raycaster.setFromCamera(mouseNDC, camera);
      raycaster.ray.intersectPlane(plane, mouseWorld);
    });

    /* ===== Thought bubbles ===== */
    const PHRASES = [
      "the sea forgets no one",
      "my reflection looks back too long",
      "light bends where i used to be",
      "every bubble is a thought escaping",
      "softly dissolving into memory",
      "the silence is breathing",
      "dreams taste like salt",
      "you were here once",
      "i hope the current remembers me",
      "where do ripples go to die?"
    ];

    function makeBubbleSprite(text){
      const w=256,h=128;
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      const x=c.getContext('2d');

      // outline + fill
      x.fillStyle='rgba(0,0,0,0.35)';
      x.strokeStyle='rgba(255,255,255,0.85)'; x.lineWidth=3;
      x.beginPath();
      x.moveTo(14,8);
      x.arcTo(w-8,8,w-8,h-8,14);
      x.arcTo(w-8,h-8,8,h-8,14);
      x.arcTo(8,h-8,8,8,14);
      x.arcTo(8,8,w-8,8,14);
      x.closePath(); x.fill(); x.stroke();

      // quick wrap
      x.font='600 22px ui-monospace, monospace';
      x.fillStyle='rgba(235,255,250,0.98)';
      x.textAlign='center'; x.textBaseline='middle';
      const words=text.split(' '); const lines=[]; let line='';
      for(const w2 of words){ const t=line?line+' '+w2:w2;
        if(x.measureText(t).width > w-36){ lines.push(line); line=w2; } else line=t;
      }
      if(line) lines.push(line);
      const startY=h/2 - (lines.length-1)*14;
      lines.forEach((L,i)=>x.fillText(L,w/2,startY+i*28));

      const tex=new THREE.CanvasTexture(c);
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false });
      const s=new THREE.Sprite(mat); s.scale.set(2.2,1.1,1);
      s.userData={ctx:x, texture:tex};
      return s;
    }

    /* ===== Custom GLSL: Iridescent Scales Shader (7s cycle) ===== */
    const fishVertexShader = /* glsl */`
      varying vec3 vWorldPos;
      varying vec3 vWorldNormal;
      varying vec2 vUv;
      uniform float uTime;
      uniform float uTailPhase;  // for subtle body undulation

      void main(){
        vUv = uv;

        // Subtle whole-body undulation (wobble along Z by X)
        float wobble = 0.02 * sin(uTime*2.0 + position.x*6.0 + uTailPhase);
        vec3 pos = position + vec3(0.0, 0.0, wobble);

        vec4 worldPos = modelMatrix * vec4(pos, 1.0);
        vWorldPos = worldPos.xyz;

        // Transform normal to world space
        vWorldNormal = normalize( mat3(modelMatrix) * normal );

        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `;

    const fishFragmentShader = /* glsl */`
      precision highp float;
      varying vec3 vWorldPos;
      varying vec3 vWorldNormal;
      varying vec2 vUv;

      uniform vec3  uBaseColor;
      uniform vec3  uViewPos;
      uniform float uTime;
      uniform float uOpacity;
      uniform float uIriPhase;

      // Hue rotation helper
      vec3 hsv2rgb(vec3 c){
        vec3 rgb = clamp( abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );
        rgb = rgb*rgb*(3.0-2.0*rgb); // smoothstep
        return c.z * mix(vec3(1.0), rgb, c.y);
      }

      // Hex tiling for scale centers
      // returns nearest hex-cell center coords and local coord
      vec2 hex(vec2 p){
        // hex grid conversion
        vec2 q = vec2( p.x*2.0/1.7320508, p.y - (mod(floor(p.x*2.0/1.7320508)+1000.0,2.0)-1.0)*0.5 );
        vec2 b = floor(q);
        vec2 r = q - b;

        vec2 g1 = vec2(b.x, b.y);
        vec2 g2 = vec2(b.x+1.0, b.y + (mod(b.x+1000.0,2.0) < 1.0 ? 0.0 : 1.0));
        vec2 g3 = vec2(b.x+1.0, b.y + (mod(b.x+1001.0,2.0) < 1.0 ? -1.0 : 0.0));

        // nearest of three candidates
        vec2 p1 = g1, p2 = g2, p3 = g3;
        vec2 h1 = vec2(p1.x*0.8660254, p1.y + (mod(p1.x+1000.0,2.0)<1.0?0.0:0.5));
        vec2 h2 = vec2(p2.x*0.8660254, p2.y + (mod(p2.x+1000.0,2.0)<1.0?0.0:0.5));
        vec2 h3 = vec2(p3.x*0.8660254, p3.y + (mod(p3.x+1000.0,2.0)<1.0?0.0:0.5));

        float d1 = distance(p, h1);
        float d2 = distance(p, h2);
        float d3 = distance(p, h3);

        vec2 hc = (d1<d2 && d1<d3) ? h1 : (d2<d3 ? h2 : h3);
        return hc;
      }

      void main(){
        // View & light directions
        vec3 N = normalize(vWorldNormal);
        vec3 V = normalize(uViewPos - vWorldPos);

        // Base UV scale — tighter tiles = smaller scales
        vec2 uv = vUv * vec2(14.0, 8.0);

        // Time-varying iridescent hue (7s cycle)
        float cycle = 6.2831853 / 7.0; // 2π/7
        float hue   = mod( (uTime + uIriPhase)*cycle*0.16, 1.0 ); // slow hue change
        // Mix cool & warm via hue; higher saturation in highlights
        vec3 iriColor = hsv2rgb(vec3(hue, 0.75, 1.0));

        // Hex-based scale cell center
        vec2 h = hex(uv);
        float distToCenter = distance(uv, h);

        // Scale disk (feathered edge)
        float scaleMask = smoothstep(0.6, 0.0, distToCenter); // 1 at center, 0 outside

        // Fresnel-like view term to make edges glint
        float fres = pow(1.0 - max(dot(N, V), 0.0), 3.0);

        // Subtle cellular modulation inside scale to fake ridges
        float ring = 0.25 + 0.75 * smoothstep(0.5, 0.15, distToCenter);

        // Base color
        vec3 base = uBaseColor;

        // Combine: base + iridescent highlight modulated by scale mask, fresnel and slow time pulsing
        float pulse = 0.6 + 0.4*sin((uTime + uIriPhase)*cycle*1.0);
        vec3 color = base * (0.55 + 0.45*ring)
                   + iriColor * (scaleMask * (0.35*fres + 0.2*pulse));

        // Gentle spec boost
        float spec = pow(max(dot(reflect(-V, N), V), 0.0), 24.0);
        color += 0.12 * spec;

        gl_FragColor = vec4(color, uOpacity);
      }
    `;

    function makeFishBodyMaterial(baseHex, iriPhase){
      const base = new THREE.Color(baseHex);
      const mat = new THREE.ShaderMaterial({
        vertexShader: fishVertexShader,
        fragmentShader: fishFragmentShader,
        transparent: true,
        uniforms: {
          uTime:      { value: 0 },
          uOpacity:   { value: 1 },
          uBaseColor: { value: new THREE.Color(base) },
          uViewPos:   { value: new THREE.Vector3() },
          uIriPhase:  { value: iriPhase },
          uTailPhase: { value: Math.random()*Math.PI*2 }
        }
      });
      return mat;
    }

    /* ===== Fins/Tails materials (translucent with blue luminescent edge) ===== */
    function finMaterial(baseHex){
      const col = new THREE.Color(baseHex).lerp(new THREE.Color('#ffffff'), 0.35);
      return new THREE.MeshStandardMaterial({
        color: col,
        roughness: 0.5,
        metalness: 0.1,
        emissive: new THREE.Color(0x355cff),
        emissiveIntensity: 0.16,
        transparent: true,
        opacity: 0.55,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
    }

    function eyeMaterial(){
      return new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 1 });
    }

    /* ===== Elegant fish model ===== */
    function createFishModel(hex){
      const group = new THREE.Group();

      // Body (ellipsoid) with iridescent shader
      const bodyGeo = new THREE.SphereGeometry(0.36, 28, 20);
      const bodyMat = makeFishBodyMaterial(hex, Math.random()*10.0);
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.scale.set(1.9, 1.0, 0.85);
      group.add(body);

      // Forked, long translucent tail (2 ribbons)
      const tailMat = finMaterial(hex);
      const tailGeo = new THREE.PlaneGeometry(0.8, 0.55, 1, 4);
      const tailL = new THREE.Mesh(tailGeo, tailMat);
      const tailR = new THREE.Mesh(tailGeo, tailMat.clone());
      tailL.position.set(-1.02, 0, 0.12);
      tailR.position.set(-1.02, 0, -0.12);
      tailL.rotation.y = Math.PI * 0.5;
      tailR.rotation.y = Math.PI * 0.5;
      group.add(tailL, tailR);

      // Dorsal & ventral long fins
      const longFinGeo = new THREE.PlaneGeometry(1.0, 0.3, 1, 5);
      const finTop = new THREE.Mesh(longFinGeo, finMaterial(hex));
      const finBot = new THREE.Mesh(longFinGeo, finMaterial(hex));
      finTop.position.set(0.1, 0.24, 0.0);  finTop.rotation.x = -Math.PI/12;
      finBot.position.set(0.05,-0.24, 0.0); finBot.rotation.x =  Math.PI/12;
      group.add(finTop, finBot);

      // Pectoral fins
      const pecGeo = new THREE.PlaneGeometry(0.45, 0.2, 1, 2);
      const pecL = new THREE.Mesh(pecGeo, finMaterial(hex));
      const pecR = new THREE.Mesh(pecGeo, finMaterial(hex));
      pecL.position.set(0.28, -0.08, 0.33);
      pecR.position.set(0.28, -0.08,-0.33);
      pecL.rotation.set(0, Math.PI/2.6,  Math.PI/12);
      pecR.rotation.set(0,-Math.PI/2.6, -Math.PI/12);
      group.add(pecL, pecR);

      // Eyes
      const eyeGeo = new THREE.SphereGeometry(0.04, 12, 12);
      const eyeL = new THREE.Mesh(eyeGeo, eyeMaterial());
      const eyeR = eyeL.clone();
      eyeL.position.set(0.55, 0.08, 0.18);
      eyeR.position.set(0.55, 0.08,-0.18);
      group.add(eyeL, eyeR);

      // Mouth (deep red, larger than eyes, flush with head)
      const mouth = new THREE.Mesh(
        new THREE.CircleGeometry(0.075, 24),
        new THREE.MeshBasicMaterial({ color: 0xaa2222, transparent: true, opacity: 1.0 })
      );
      mouth.position.set(0.72, 0.02, 0.0); // slightly into the head to look attached
      mouth.rotation.y = Math.PI/2;
      group.add(mouth);

      group.userData = { body, bodyMat, tailL, tailR, finTop, finBot, pecL, pecR, eyes:[eyeL,eyeR], mouth };
      return group;
    }

    /* ===== Fish class (calm drift + gentle avoidance + smooth turning) ===== */
    const BOUNDS = { x: 5.8, y: 2.9, z: 3.8 };

    class Fish {
      constructor(hex){
        this.group = createFishModel(hex);
        this.thought = makeBubbleSprite(choose(PHRASES));
        this.thought.position.set(0, 0.95, 0);
        this.group.add(this.thought);

        // initial placement & motion
        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel = new THREE.Vector3(rand(-0.01,0.01), rand(-0.005,0.005), rand(-0.008,0.008));
        this.speed = rand(0.003, 0.010);
        this.dead = false;

        // drift phases
        this.tailPhase = Math.random()*Math.PI*2;
        this.finPhase  = Math.random()*Math.PI*2;
        this.mouthPhase= Math.random()*Math.PI*2;
        this.driftPhase= Math.random()*Math.PI*2;

        // orientation
        this.heading = 0;

        scene.add(this.group);
      }

      fade(){
        if (this.dead) return;
        this.dead = true;

        // remove existing thought bubble immediately
        this.group.remove(this.thought); scene.remove(this.thought);

        const farewell = makeBubbleSprite("i will remember this.");
        farewell.position.copy(this.group.position).add(new THREE.Vector3(0,0.9,0));
        scene.add(farewell);

        const start = performance.now();
        const fadeOut = () => {
          const t = (performance.now() - start) / 1500;
          // body shader opacity
          this.group.userData.bodyMat.uniforms.uOpacity.value = clamp(1 - t, 0, 1);
          // standard mats
          this.group.traverse(o=>{
            if(o.material && o.material !== this.group.userData.bodyMat){
              if('opacity' in o.material) o.material.opacity = clamp(1 - t, 0, 1);
            }
          });
          if (t < 1) requestAnimationFrame(fadeOut);
          else scene.remove(this.group);
        };
        fadeOut();

        const msgStart = performance.now();
        const msgAnim = ()=>{
          const t = (performance.now() - msgStart) / 4000;
          farewell.position.y += 0.002;
          farewell.material.opacity = clamp(1 - t, 0, 1);
          if (t < 1) requestAnimationFrame(msgAnim);
          else scene.remove(farewell);
        };
        msgAnim();
      }

      update(dt, time){
        if (this.dead) return;

        const UD = this.group.userData;

        // ===== Calm drift: small sinusoidal steering + gentle wander =====
        const driftTurn = Math.sin(time*0.5 + this.driftPhase) * 0.003;  // slow turning
        const driftLift = Math.cos(time*0.4 + this.driftPhase) * 0.0008; // gentle vertical

        this.vel.x += driftTurn;
        this.vel.y += driftLift;
        this.vel.z += Math.sin(time*0.37 + this.driftPhase)*0.0009;

        // ===== Subtle mouse avoidance (short radius + low strength) =====
        const toMouse = new THREE.Vector3().subVectors(this.group.position, mouseWorld);
        const dist = toMouse.length();
        const radius = 1.4; // smaller radius
        if (Number.isFinite(dist) && dist < radius){
          const s = (radius - dist) / radius;
          toMouse.normalize();
          this.vel.addScaledVector(toMouse, s * 0.015); // reduced strength
        }

        // velocity damping to avoid ping-pong behavior
        this.vel.multiplyScalar(0.985);

        // clamp overall speed
        if (this.vel.length() > this.speed) this.vel.setLength(this.speed);

        // move
        this.group.position.addScaledVector(this.vel, dt * 60);

        // bounds (soft bounce)
        const p=this.group.position, v=this.vel;
        if (p.x<-BOUNDS.x){ p.x=-BOUNDS.x; v.x=Math.abs(v.x)*0.8; }
        if (p.x> BOUNDS.x){ p.x= BOUNDS.x; v.x=-Math.abs(v.x)*0.8; }
        if (p.y<-BOUNDS.y){ p.y=-BOUNDS.y; v.y=Math.abs(v.y)*0.8; }
        if (p.y> BOUNDS.y){ p.y= BOUNDS.y; v.y=-Math.abs(v.y)*0.8; }
        if (p.z<-BOUNDS.z){ p.z=-BOUNDS.z; v.z=Math.abs(v.z)*0.8; }
        if (p.z> BOUNDS.z){ p.z= BOUNDS.z; v.z=-Math.abs(v.z)*0.8; }

        // smooth orientation toward velocity
        const dir = this.vel.clone().normalize();
        if (dir.lengthSq() > 0.00001){
          const targetYaw = Math.atan2(-dir.z, dir.x);
          this.heading = lerpAngle(this.heading, targetYaw, clamp(2.2*dt, 0, 1));
          this.group.rotation.y = this.heading;
          this.group.rotation.z = Math.sin(time*0.7 + this.tailPhase)*0.03; // tiny roll
        }

        // fins & tail wobble (realistic amplitude)
        const tailAngle = Math.sin(time*2.0 + this.tailPhase) * THREE.MathUtils.degToRad(10);
        UD.tailL.rotation.z =  tailAngle;
        UD.tailR.rotation.z = -tailAngle;
        const finAng = Math.sin(time*1.6 + this.finPhase) * THREE.MathUtils.degToRad(5);
        UD.finTop.rotation.z =  finAng;
        UD.finBot.rotation.z = -finAng;
        const pecAng = Math.sin(time*2.2 + this.finPhase)*THREE.MathUtils.degToRad(6);
        UD.pecL.rotation.x =  pecAng*0.5;
        UD.pecR.rotation.x = -pecAng*0.5;

        // mouth breathing (attached & larger/red)
        const mouthOpen = (Math.sin(time*2.0 + this.mouthPhase)*0.5+0.5)*0.25 + 0.9; // 0.9..1.15
        UD.mouth.scale.set(1, mouthOpen, 1);

        // shader uniforms update
        UD.bodyMat.uniforms.uTime.value = time;
        UD.bodyMat.uniforms.uViewPos.value.copy(camera.position);

        // thought bubble faces camera
        this.thought.lookAt(camera.position);
      }
    }

    /* ===== Build 14 fish with distinct hues ===== */
    const FISH = [];
    for (let i=0;i<14;i++){
      const col = new THREE.Color().setHSL(i/14, 0.85, 0.55);
      FISH.push( new Fish(`#${col.getHexString()}`) );
    }

    /* ===== Click-to-fade ===== */
    addEventListener('click', e=>{
      mouseNDC.x = (e.clientX/innerWidth)*2 - 1;
      mouseNDC.y = -(e.clientY/innerHeight)*2 + 1;
      raycaster.setFromCamera(mouseNDC, camera);

      const candidates = [];
      for (const f of FISH){ f.group.traverse(obj=>{ if(obj.isMesh) candidates.push(obj); }); }
      const hits = raycaster.intersectObjects(candidates, true);
      if (hits.length){
        const hit = hits[0].object;
        const fish = FISH.find(ff=>{
          let found=false; ff.group.traverse(o=>{ if(o===hit) found=true; }); return found;
        });
        if (fish) fish.fade();
      }
    });

    /* ===== Floating water bubbles ===== */
    const bubbleCount = 220;
    const bubbleGeo = new THREE.BufferGeometry();
    const bPos = new Float32Array(bubbleCount*3);
    const bSpeed = new Float32Array(bubbleCount);
    for (let i=0;i<bubbleCount;i++){
      bPos[i*3+0] = rand(-6,6);
      bPos[i*3+1] = rand(-3,3);
      bPos[i*3+2] = rand(-4,4);
      bSpeed[i]   = rand(0.12,0.45);
    }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(bPos,3));
    const bubbleMat = new THREE.PointsMaterial({
      color:0xdff9ff, size:0.06, sizeAttenuation:true,
      transparent:true, opacity:0.7, depthWrite:false, blending:THREE.AdditiveBlending
    });
    const bubbles = new THREE.Points(bubbleGeo, bubbleMat);
    scene.add(bubbles);
    function updateBubbles(dt){
      const arr=bubbleGeo.attributes.position.array;
      for(let i=0;i<bubbleCount;i++){
        arr[i*3+1]+=bSpeed[i]*dt;
        if(arr[i*3+1]>3.2){ arr[i*3+1]=-3.2; arr[i*3]=rand(-6,6); arr[i*3+2]=rand(-4,4); }
      }
      bubbleGeo.attributes.position.needsUpdate = true;
    }

    /* ===== Shark (PNG plane behind fish) ===== */
    const SHARK_SRC = 'shark.png';
    class Shark {
      constructor(){
        this.dir=1; this.speed=0.55;
        this.y=rand(0.2,1.2); this.z=-7.8;
        this.phase=Math.random()*Math.PI*2; this.flipBound=16.5;
        new THREE.TextureLoader().load(SHARK_SRC, t=>{
          t.colorSpace = THREE.SRGBColorSpace; t.premultiplyAlpha = true;
          const aspect=t.image.width/t.image.height, W=19, H=W/aspect;
          const m=new THREE.MeshBasicMaterial({ map:t, transparent:true, opacity:0.75, depthWrite:false, side:THREE.DoubleSide, alphaTest:0.03 });
          this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(W,H), m);
          this.mesh.position.set(-this.flipBound-0.2, this.y, this.z);
          scene.add(this.mesh);
        });
      }
      update(dt, t){
        if(!this.mesh) return;
        this.mesh.position.x += this.dir * this.speed * dt;
        this.mesh.position.y  = this.y + Math.sin(t*0.25 + this.phase)*0.12;
        if(this.dir>0 && this.mesh.position.x> this.flipBound){ this.dir=-1; this.mesh.rotation.y=Math.PI; }
        else if(this.dir<0 && this.mesh.position.x<-this.flipBound){ this.dir= 1; this.mesh.rotation.y=0; }
      }
    }
    const SHARK = new Shark();

    /* ===== Resize ===== */
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ===== Animate ===== */
    let last = performance.now();
    function tick(now){
      const dt = Math.min((now - last)/1000, 0.05); last = now;
      const t  = now * 0.001;

      // Smooth horizontal camera pan
      const targetX = mouseX * panRange;
      camera.position.x += (targetX - camera.position.x)*0.05;
      camera.lookAt(0,0,0);

      // Fish updates
      for(const f of FISH) f.update(dt, t);

      // Bubbles & shark
      updateBubbles(dt);
      SHARK.update(dt, t);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
