<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      /* JS animates this gradient each frame; start a notch lighter than the last version */
      background: linear-gradient(to bottom,
        hsl(210 55% 30%) 0%,
        hsl(216 55% 20%) 40%,
        hsl(222 55% 12%) 100%
      );
    }
    canvas { display:block }

    /* subtle film grain */
    #dither{
      position:fixed; inset:0; pointer-events:none; opacity:.12; z-index:2;
      background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="black" opacity="0"/><rect x="0" y="0" width="2" height="2" fill="white" opacity="0.07"/><rect x="2" y="2" width="2" height="2" fill="white" opacity="0.07"/></svg>');
      image-rendering:pixelated; background-size:4px; background-repeat:repeat; mix-blend-mode:overlay;
    }

    /* overlays */
    #overlay{
      position:fixed; inset:0; pointer-events:none; z-index:4;
      display:flex; align-items:flex-end; justify-content:flex-end;
      padding: 12px 14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#b3f4ff; text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{ font-weight:700; letter-spacing:.5px; font-size:12px; color:#9effc7; }

    #instructions{
      position:fixed; left:12px; bottom:10px; z-index:4; pointer-events:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px; line-height:1.5;
      color:#9effc7; /* same color as title */
      text-shadow:0 1px 2px rgba(0,0,0,.3);
      white-space:pre-line;
    }
  </style>
</head>
<body>
  <div id="dither"></div>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>
  <div id="instructions">move mouse horizontally to pan
click a fish to let it fade and leave a note</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /* ===== Scene / World root (for mouse parallax) ===== */
    const scene = new THREE.Scene();
    const world = new THREE.Group();   // move this with the mouse for parallax
    scene.add(world);

    // Slightly lighter than previous dark set; fog deepens distance
    scene.fog = new THREE.FogExp2(0x0f0930, 0.055);

    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, premultipliedAlpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.9; // keep colors rich without blowing highlights
    document.body.appendChild(renderer.domElement);

    /* ===== Lights (no emissive on fish; lighting does the work) ===== */
    const hemi = new THREE.HemisphereLight(0xaad9ff, 0x0b0018, 0.45);
    const key  = new THREE.DirectionalLight(0xa7d2ff, 1.15); key.position.set(4, 6, 2);
    const fill = new THREE.DirectionalLight(0x66ffd2, 0.5); fill.position.set(-5, 2, -3);
    const rim  = new THREE.DirectionalLight(0x7a78ff, 0.7); rim.position.set(0, 3.5, -6);
    scene.add(hemi, key, fill, rim);

    /* ===== Helpers ===== */
    const rand = (a,b)=> a + Math.random()*(b-a);
    const choose = arr => arr[(Math.random()*arr.length)|0];

    /* ===== Darker—but one tone lighter than before—hue-shifting background (blue-green ↔ blue-purple) ===== */
    const BG = {
      HUE_MIN: 190,   // blue-green side
      HUE_MAX: 255,   // blue-purple side
      SAT: 55,        // %
      L1: 30,         // top lightness (lighter than last dark set)
      L2: 20,         // mid
      L3: 12,         // bottom
      speed: 0.06
    };
    function updateBackground(nowMs){
      const t = nowMs * 0.001;
      const u = (Math.sin(t * BG.speed) + 1) / 2; // 0..1
      const hue = BG.HUE_MIN + u * (BG.HUE_MAX - BG.HUE_MIN);
      const h1 = hue, h2 = (hue + 6) % 360, h3 = (hue + 12) % 360;
      document.body.style.background =
        `linear-gradient(to bottom,
          hsl(${h1} ${BG.SAT}% ${BG.L1}%) 0%,
          hsl(${h2} ${BG.SAT}% ${BG.L2}%) 40%,
          hsl(${h3} ${BG.SAT}% ${BG.L3}%) 100%
        )`;
    }

    /* ===== Soft God-Rays (additive translucent cones from above) ===== */
    function makeGodRay(){
      const geo = new THREE.ConeGeometry(6.5, 16, 64, 1, true);
      geo.rotateX(-Math.PI/2);
      const mat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{
          uTime:{value:0},
          uTint:{value:new THREE.Color(0xbfe8ff)},
          uOpacity:{value:0.18}
        },
        vertexShader:/*glsl*/`
          varying vec2 vUv;
          void main(){
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
          }
        `,
        fragmentShader:/*glsl*/`
          varying vec2 vUv;
          uniform vec3 uTint;
          uniform float uTime, uOpacity;
          // soft radial / vertical falloff + slow shifting bands
          float hash(float n){ return fract(sin(n)*43758.5453123); }
          void main(){
            float r = 1.0 - vUv.y;                // closer to the top is brighter
            float radial = smoothstep(0.0, 0.6, r) * (1.0 - smoothstep(0.6, 1.0, r));
            float band = 0.5 + 0.5*sin(vUv.x*20.0 + uTime*0.35);
            float alpha = radial * (0.35 + 0.65*band);
            alpha *= (1.0 - vUv.x*0.6);
            alpha *= uOpacity;
            if(alpha < 0.01) discard;
            gl_FragColor = vec4(uTint, alpha);
          }
        `
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.set(rand(-2,2), 5.8, rand(-1.5,1.5));
      m.rotation.z = rand(-0.15,0.15);
      m.userData.speed = rand(0.3, 0.7);
      return m;
    }
    const RAYS = [];
    for(let i=0;i<4;i++){ const r=makeGodRay(); RAYS.push(r); world.add(r); }

    /* ===== Speech bubbles (reusable) ===== */
    function makeBubbleSprite(text){
      const w=256,h=128;
      const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h;
      const ctx=cvs.getContext('2d');
      ctx.fillStyle='rgba(0,0,0,0.24)';
      ctx.strokeStyle='rgba(220,255,250,0.75)'; ctx.lineWidth=2;
      roundRect(ctx,8,8,w-16,h-16,14,true,true);
      ctx.font='600 22px ui-monospace, monospace';
      ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
      wrapText(ctx,text,w/2,h/2,w-36,28);
      const tex=new THREE.CanvasTexture(cvs);
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false, opacity:1 });
      const spr=new THREE.Sprite(mat); spr.scale.set(2.2,1.1,1);
      spr.userData={canvas:cvs,ctx,texture:tex, material:mat};
      return spr;
    }
    function updateBubbleText(sprite, text){
      const { canvas:cvs, ctx, texture:tex } = sprite.userData;
      const w=cvs.width,h=cvs.height;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle='rgba(0,0,0,0.24)';
      ctx.strokeStyle='rgba(220,255,250,0.75)'; ctx.lineWidth=2;
      roundRect(ctx,8,8,w-16,h-16,14,true,true);
      ctx.font='600 22px ui-monospace, monospace';
      ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
      wrapText(ctx,text,w/2,h/2,w-36,28);
      tex.needsUpdate=true;
    }
    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      if(fill)ctx.fill();
      if(stroke)ctx.stroke();
    }
    function wrapText(ctx,text,x,y,maxWidth,lineHeight){
      const words=text.split(' '); const lines=[]; let line='';
      for(const w of words){
        const test=line?line+' '+w:w;
        if(ctx.measureText(test).width>maxWidth){ lines.push(line); line=w; } else line=test;
      }
      if(line)lines.push(line);
      const total=lines.length*lineHeight; let curY=y-total/2+lineHeight/2;
      for(const l of lines){ ctx.fillText(l,x,curY); curY+=lineHeight; }
    }

    /* ===== Procedural fish-scale shader (no emissive) ===== */
    // Bright sheen colors to pick from (used where light hits)
    const SHEEN_COLORS = [
      new THREE.Color(0x7FFFD4), // aquamarine
      new THREE.Color(0x7FB3FF), // soft blue
      new THREE.Color(0x9A7BFF), // purple
      new THREE.Color(0x66FFC2), // minty green
      new THREE.Color(0x89A8FF), // periwinkle
      new THREE.Color(0x52E8FF)  // azure
    ];

    const FishScaleMaterial = (sheenColor)=>{
      return new THREE.ShaderMaterial({
        transparent:true, depthWrite:true,
        uniforms:{
          uLightDir: { value: new THREE.Vector3().copy(key.position).normalize() },
          uColorDark: { value: new THREE.Color(0x030308) },       // almost black
          uSheen: { value: sheenColor.clone() },                  // bright saturated color
          uOpacity: { value: 1.0 },                               // for fading
          uTime: { value: 0 },
          uScale: { value: 6.0 }                                  // scale density
        },
        vertexShader:/*glsl*/`
          varying vec3 vNormal;
          varying vec3 vWorldPos;
          varying vec2 vUv;
          void main(){
            vNormal = normalize(normalMatrix * normal);
            vUv = uv;
            vec4 wp = modelMatrix * vec4(position,1.0);
            vWorldPos = wp.xyz;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader:/*glsl*/`
          varying vec3 vNormal;
          varying vec3 vWorldPos;
          varying vec2 vUv;
          uniform vec3 uLightDir;
          uniform vec3 uColorDark;
          uniform vec3 uSheen;
          uniform float uOpacity;
          uniform float uTime;
          uniform float uScale;

          // Build a scalloped "scale" mask using UV rows with offsets
          float scaleMask(vec2 uv){
            // tile uv
            vec2 T = uv * uScale;
            float row = floor(T.y);
            // offset every other row for staggered scales
            float offset = mod(row, 2.0) * 0.5;
            vec2 cell = fract(vec2(T.x + offset, T.y));
            // circle centered near bottom of the cell for "scale" arc
            vec2 c = cell - vec2(0.5, 0.25);
            float d = length(c) * 2.0; // normalize to cell
            // sharp scallop edge
            float edge = smoothstep(0.85, 0.70, d);
            // fade top of cell to prevent double-overlap
            float head = smoothstep(0.0, 0.2, cell.y);
            return edge * head;
          }

          void main(){
            // Lambert
            vec3 L = normalize(uLightDir);
            float ndotl = max(dot(normalize(vNormal), L), 0.0);

            // Scale pattern
            float mask = scaleMask(vUv);

            // Sheen ramp — strong where light hits, otherwise almost black
            vec3 base = uColorDark;
            vec3 highlight = uSheen;
            // emphasize contrast with a power curve on ndotl
            float sheen = pow(ndotl, 1.5);

            // combine: only show sheen strongly where the scale mask contributes
            vec3 col = mix(base, highlight, clamp(sheen * (0.4 + 0.6*mask), 0.0, 1.0));

            gl_FragColor = vec4(col, uOpacity);
            if(gl_FragColor.a < 0.02) discard;
          }
        `
      });
    };

    /* ===== Fish geometry with fixed tail placement & natural fin wiggle ===== */
    const PHRASES = [
      'i am not real','today i forgot myself','be kind to the void','do fish dream?',
      '404: meaning not found','blink slowly','pretend to be water','becoming … becoming','a small thought floats'
    ];
    const BOUNDS = { x: 5.8, y: 2.9, z: 3.8 };

    function makeFishMesh(){
      const g=new THREE.Group(); g.userData.isFish = true;

      // Body
      const radius = rand(0.25,0.38);
      const sx = rand(1.7, 2.2);
      const bodyGeo=new THREE.IcosahedronGeometry(radius, 0);
      bodyGeo.computeBoundingBox();
      bodyGeo.scale(sx, 1, 1);

      const sheen = choose(SHEEN_COLORS);
      const bodyMat = FishScaleMaterial(sheen);
      const body=new THREE.Mesh(bodyGeo, bodyMat); g.add(body);

      // Tail: pivot-friendly geometry (base at origin), then positioned to body's left edge
      const tailLen = 0.38;
      const tailGeo=new THREE.ConeGeometry(0.20, tailLen, 3);
      // move cone so the flat base is at local origin (for nice pivot)
      tailGeo.translate(0, -tailLen*0.5, 0); // center at middle; we'll use a pivot
      const tailMat = FishScaleMaterial(sheen);
      const tailMesh=new THREE.Mesh(tailGeo, tailMat);

      const tailPivot = new THREE.Group();
      tailPivot.add(tailMesh);
      // rotate pivot so tail points backward along -X
      tailPivot.rotation.z = Math.PI/2;

      // compute body extent on X after scale
      const bodyMinX = -radius * sx;
      tailPivot.position.set(bodyMinX - 0.06, 0, 0); // attach just beyond the body
      g.add(tailPivot);

      // Fins (top/bottom small cones), share sheen
      const finGeo=new THREE.ConeGeometry(0.08,0.18,3);
      finGeo.translate(0, -0.09, 0);
      const finMat = FishScaleMaterial(sheen);
      const finL=new THREE.Mesh(finGeo,finMat);
      const finR=new THREE.Mesh(finGeo,finMat.clone());
      finL.position.set(0.08, -0.05, 0.16); finL.rotation.z = -Math.PI/2.6;
      finR.position.set(0.08, -0.05,-0.16); finR.rotation.z = -Math.PI/2.6; finR.rotation.y = Math.PI;
      g.add(finL,finR);

      // Eyes (non-shader, tiny)
      const eyeGeo=new THREE.SphereGeometry(0.038,12,12);
      const eyeMat=new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.25, metalness:0.1 });
      const eyeL=new THREE.Mesh(eyeGeo,eyeMat), eyeR=new THREE.Mesh(eyeGeo,eyeMat);
      eyeL.position.set(0.42,0.06,0.12); eyeR.position.set(0.42,0.06,-0.12); g.add(eyeL,eyeR);

      // Thought bubble
      const bubble=makeBubbleSprite(choose(PHRASES)); bubble.position.set(0,0.9,0); g.add(bubble);

      // save parts
      g.userData = {
        ...g.userData,
        body, tailPivot, tailMesh, fins:[finL,finR], eyes:[eyeL,eyeR], bubble,
        mats:[bodyMat, tailMat, finMat, finR.material],
        sheen
      };

      return g;
    }

    class Fish{
      constructor(){
        this.group=makeFishMesh(); world.add(this.group);
        // starting transform
        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel=new THREE.Vector3(rand(-0.02,0.02), rand(-0.01,0.01), rand(-0.015,0.015));
        this.turn=new THREE.Vector3(rand(-0.001,0.001), rand(-0.001,0.001), rand(-0.001,0.001));
        this.speed=rand(0.003,0.018);
        this.phase = Math.random()*Math.PI*2;

        this.fading = false;
        this.fade = 1.0; // opacity
      }
      update(dt, t){
        if(!this.group) return;

        // wander
        this.vel.x += this.turn.x * dt; this.vel.y += this.turn.y * dt; this.vel.z += this.turn.z * dt;
        this.vel.clampLength(0, this.speed);
        this.group.position.addScaledVector(this.vel, dt * 60);

        // clamp & bounce
        const p = this.group.position, v = this.vel;
        if (p.x < -BOUNDS.x){ p.x = -BOUNDS.x; v.x = Math.abs(v.x); }
        if (p.x >  BOUNDS.x){ p.x =  BOUNDS.x; v.x = -Math.abs(v.x); }
        if (p.y < -BOUNDS.y){ p.y = -BOUNDS.y; v.y = Math.abs(v.y); }
        if (p.y >  BOUNDS.y){ p.y =  BOUNDS.y; v.y = -Math.abs(v.y); }
        if (p.z < -BOUNDS.z){ p.z = -BOUNDS.z; v.z = Math.abs(v.z); }
        if (p.z >  BOUNDS.z){ p.z =  BOUNDS.z; v.z = -Math.abs(v.z); }

        // face swim direction
        const dir = this.vel.clone().normalize();
        if (dir.lengthSq() > 0.0001){
          const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dir);
          this.group.quaternion.slerp(targetQuat, 0.08);
        }

        // natural tail & fin wiggle
        const wag = Math.sin(t*6.0 + this.phase) * 0.35; // radians
        this.group.userData.tailPivot.rotation.y = wag;
        this.group.userData.fins.forEach((fin,i)=>{
          fin.rotation.y = Math.sin(t*5.5 + this.phase + i)*0.12;
        });

        // bubble faces camera
        this.group.userData.bubble.lookAt(camera.position);

        // handle fading (fish & its existing bubble together)
        if(this.fading){
          this.fade = Math.max(0, this.fade - dt*0.6);
          for(const m of this.group.userData.mats){ m.uniforms.uOpacity.value = this.fade; }
          this.group.userData.bubble.material.opacity = this.fade;
          // also make eyes fade
          this.group.userData.eyes.forEach(e=>{ e.material.transparent=true; e.material.opacity=this.fade; });
          if(this.fade<=0.0){
            // remove fish meshes + its bubble
            world.remove(this.group);
            this.group.traverse(o=>{ if(o.material && !o.material.isShaderMaterial){ o.material.dispose?.(); } if(o.geometry){ o.geometry.dispose?.(); }});
            // leave a memory bubble
            const mem = makeBubbleSprite('i will remember this.');
            mem.position.copy(this.group.position.clone().add(new THREE.Vector3(0,0.9,0)));
            world.add(mem);
            // let it float & slowly fade after a while
            const start = performance.now();
            const life = 5000;
            const tickMem = (now)=>{
              const dtm = (now - start);
              mem.position.y += 0.0003 * (dtm);
              if(dtm > life){
                const a = 1 - (dtm - life)/1500;
                mem.material.opacity = Math.max(0, a);
                if(a<=0){ world.remove(mem); mem.material.map.dispose(); mem.material.dispose(); return; }
              }
              requestAnimationFrame(tickMem);
            };
            requestAnimationFrame(tickMem);

            // mark dead
            this.group = null;
          }
        }
      }
      triggerFade(){
        if(this.fading || !this.group) return;
        this.fading = true;
      }
    }

    // Make a school
    const FISH=[];
    for(let i=0;i<24;i++) FISH.push(new Fish());

    // Random thoughts
    setInterval(()=>{
      const alive = FISH.filter(f=>f.group && !f.fading);
      if(!alive.length) return;
      const f = choose(alive);
      if (f) {
        const bubble = f.group.userData.bubble;
        updateBubbleText(bubble, choose(PHRASES));
      }
    }, 1800);

    /* ===== Mouse parallax pan (horizontal) ===== */
    let mouseX = 0; // -1..1
    const panRange = 1.2;
    addEventListener('pointermove', (e)=>{
      const nx = (e.clientX / innerWidth) * 2 - 1;
      mouseX = THREE.MathUtils.clamp(nx, -1, 1);
    });

    /* ===== Click-to-fade via raycaster ===== */
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    addEventListener('pointerdown', (e)=>{
      mouse.x =  (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      // collect fish meshes to test
      const targets = [];
      world.traverse(o=>{ if(o.userData && o.userData.isFish){ targets.push(o); }});
      const meshes = [];
      for(const g of targets){ g.traverse(o=>{ if(o.isMesh){ meshes.push(o); }}); }
      const hit = ray.intersectObjects(meshes, true)[0];
      if(hit){
        // find the Fish instance that owns this mesh
        const fish = FISH.find(f=> f.group && hit.object.isMesh && f.group.id === hit.object.parent?.parent?.id || f.group?.id === hit.object.parent?.id || f.group?.id === hit.object.id );
        // More reliable: climb parents to root that has isFish
        let root = hit.object;
        while(root.parent && !root.userData.isFish) root = root.parent;
        const f2 = FISH.find(f=> f.group === root);
        (f2 || fish)?.triggerFade();
      }
    });

    /* ===== Resize ===== */
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ===== Tick ===== */
    let last = performance.now();
    function tick(now){
      const dt = Math.min((now - last)/1000, 0.05); last = now;
      const t = now * 0.001;

      // bg hue animation
      updateBackground(now);

      // god-rays shimmer
      for(const r of RAYS){
        r.material.uniforms.uTime.value = t;
        r.position.x += Math.sin(t * r.userData.speed + r.id)*0.0008;
        r.position.z += Math.cos(t * r.userData.speed + r.id)*0.0006;
      }

      // mouse parallax (smooth lerp)
      world.position.x = THREE.MathUtils.lerp(world.position.x, -mouseX * panRange, 0.08);

      // update fish
      for(const f of FISH) f.update(dt, t);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
