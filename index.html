<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish — Realistic Tones</title>
  <style>
    html,body{
      height:100%; margin:0; overflow:hidden;
    }
    /* Put the gradient on a behind-the-canvas layer so only the BG shifts hue */
    #bg {
      position:fixed; inset:0; z-index:-1; pointer-events:none;
      background: linear-gradient(to bottom, #6fb7bf 0%, #3d69b4 45%, #1a1650 100%);
      animation: oceanCool 140s ease-in-out infinite alternate;
    }
    /* Seamless cool-only palette: green-blue -> blue -> blue-purple, then back */
    @keyframes oceanCool {
      0%   { background: linear-gradient(to bottom, #6fb7bf 0%, #3d69b4 45%, #1a1650 100%); }   /* green-blue */
      50%  { background: linear-gradient(to bottom, #5ca3d1 0%, #3f5ec8 45%, #17124a 100%); }   /* blue */
      100% { background: linear-gradient(to bottom, #5a98d8 0%, #4a51cf 45%, #1f1a63 100%); }   /* blue-purple */
    }

    canvas{ display:block }

    #overlay{
      position:fixed; inset:0; pointer-events:none; z-index:3;
      display:flex; align-items:flex-end; justify-content:flex-end;
      padding:12px 14px;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      color:#b3f4ff; text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{ font-weight:700; letter-spacing:.5px; font-size:12px; color:#9effc7; }
  </style>
</head>
<body>
  <div id="bg"></div>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /* ===== Scene / Renderer / Camera ===== */
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0e0830, 0.06);

    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.55;
    document.body.appendChild(renderer.domElement);

    /* ===== Lights (cool blue) ===== */
    const hemi = new THREE.HemisphereLight(0xbfeaff, 0x0f1033, 0.7);
    const key  = new THREE.PointLight(0x7cd9ff, 24, 120, 1.8); key.position.set(5, 4, 6);
    const fill = new THREE.PointLight(0x6ff0d4,  9, 120, 1.8); fill.position.set(-5, 1.2, 5);
    const rim  = new THREE.PointLight(0x6b6bff, 14, 160, 2.2); rim.position.set(0, 3.6, -9);
    scene.add(hemi, key, fill, rim);

    /* ===== Utils ===== */
    const rand  = (a,b)=>a+Math.random()*(b-a);
    const choose=a=>a[(Math.random()*a.length)|0];
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
    function lerpAngle(a,b,t){ let d=(b-a+Math.PI)%(2*Math.PI)-Math.PI; return a+d*t; }

    /* ===== Mouse (pan + subtle avoidance) ===== */
    const raycaster=new THREE.Raycaster();
    const mouseNDC=new THREE.Vector2();
    const plane=new THREE.Plane(new THREE.Vector3(0,0,1), 0);
    const mouseWorld=new THREE.Vector3(999,999,0);
    let mouseX=0; const panRange=1.2;

    addEventListener('mousemove',e=>{
      mouseX=(e.clientX/innerWidth)*2-1;
      mouseNDC.x=mouseX; mouseNDC.y=-(e.clientY/innerHeight)*2+1;
      raycaster.setFromCamera(mouseNDC,camera);
      raycaster.ray.intersectPlane(plane,mouseWorld);
    });

    /* ===== Thought bubbles ===== */
    const PHRASES=[
      "the sea forgets no one",
      "my reflection looks back too long",
      "light bends where i used to be",
      "every bubble is a thought escaping",
      "softly dissolving into memory",
      "the silence is breathing",
      "dreams taste like salt",
      "you were here once",
      "i hope the current remembers me",
      "where do ripples go to die?"
    ];

    function makeBubbleSprite(text){
      const w=256,h=128; const c=document.createElement('canvas'); c.width=w; c.height=h;
      const x=c.getContext('2d');
      x.fillStyle='rgba(0,0,0,0.35)';
      x.strokeStyle='rgba(255,255,255,0.85)'; x.lineWidth=3;
      x.beginPath(); x.moveTo(14,8);
      x.arcTo(w-8,8,w-8,h-8,14);
      x.arcTo(w-8,h-8,8,h-8,14);
      x.arcTo(8,h-8,8,8,14);
      x.arcTo(8,8,w-8,8,14);
      x.closePath(); x.fill(); x.stroke();

      x.font='600 22px ui-monospace, monospace';
      x.fillStyle='rgba(235,255,250,0.98)';
      x.textAlign='center'; x.textBaseline='middle';
      const words=text.split(' '), lines=[]; let line='';
      for(const w2 of words){ const t=line?line+' '+w2:w2;
        if(x.measureText(t).width>w-36){ lines.push(line); line=w2; } else line=t;
      }
      if(line) lines.push(line);
      const startY=h/2-(lines.length-1)*14;
      lines.forEach((L,i)=>x.fillText(L,w/2,startY+i*28));

      const tex=new THREE.CanvasTexture(c);
      const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false});
      const s=new THREE.Sprite(mat); s.scale.set(2.2,1.1,1);
      s.userData={ctx:x,texture:tex};
      return s;
    }

    /* ===== GLSL Iridescent Scales (desaturated realistic) ===== */
    const fishVertexShader = /* glsl */`
      varying vec3 vWorldPos;
      varying vec3 vWorldNormal;
      varying vec2 vUv;
      uniform float uTime;
      uniform float uTailPhase;

      void main(){
        vUv = uv;
        // Subtle whole-body undulation
        float wobble = 0.018 * sin(uTime*2.0 + position.x*6.0 + uTailPhase);
        vec3 pos = position + vec3(0.0, 0.0, wobble);

        vec4 worldPos = modelMatrix * vec4(pos,1.0);
        vWorldPos = worldPos.xyz;
        vWorldNormal = normalize(mat3(modelMatrix)*normal);
        gl_Position = projectionMatrix * viewMatrix * worldPos;
      }
    `;

    const fishFragmentShader = /* glsl */`
      precision highp float;
      varying vec3 vWorldPos;
      varying vec3 vWorldNormal;
      varying vec2 vUv;

      uniform vec3  uBaseColor;
      uniform vec3  uViewPos;
      uniform float uTime;
      uniform float uOpacity;
      uniform float uIriPhase;

      vec3 hsv2rgb(vec3 c){
        vec3 rgb = clamp( abs(mod(c.x*6.0 + vec3(0.0,4.0,2.0), 6.0)-3.0)-1.0, 0.0, 1.0 );
        rgb = rgb*rgb*(3.0-2.0*rgb);
        return c.z * mix(vec3(1.0), rgb, c.y);
      }

      // Hex center helper — enough to make soft circular cells
      vec2 hex(vec2 p){
        vec2 q = vec2(p.x*2.0/1.7320508, p.y - (mod(floor(p.x*2.0/1.7320508)+1000.0,2.0)-1.0)*0.5);
        vec2 b = floor(q);
        vec2 p1 = vec2(b.x, b.y);
        vec2 p2 = vec2(b.x+1.0, b.y + (mod(b.x+1000.0,2.0)<1.0?0.0:1.0));
        vec2 p3 = vec2(b.x+1.0, b.y + (mod(b.x+1001.0,2.0)<1.0?-1.0:0.0));
        vec2 h1 = vec2(p1.x*0.8660254, p1.y + (mod(p1.x+1000.0,2.0)<1.0?0.0:0.5));
        vec2 h2 = vec2(p2.x*0.8660254, p2.y + (mod(p2.x+1000.0,2.0)<1.0?0.0:0.5));
        vec2 h3 = vec2(p3.x*0.8660254, p3.y + (mod(p3.x+1000.0,2.0)<1.0?0.0:0.5));
        float d1=distance(p,h1), d2=distance(p,h2), d3=distance(p,h3);
        return (d1<d2 && d1<d3)?h1:(d2<d3?h2:h3);
      }

      void main(){
        vec3 N = normalize(vWorldNormal);
        vec3 V = normalize(uViewPos - vWorldPos);

        // Subtle hex tiling for scale cells
        vec2 uv = vUv * vec2(14.0, 8.0);
        vec2 h = hex(uv);
        float d = distance(uv, h);
        float scaleMask = smoothstep(0.7, 0.05, d); // soft round cell

        // Fresnel for wet edge glint
        float fres = pow(1.0 - max(dot(N,V), 0.0), 3.0);

        // Time-varying iridescence: moderate & natural
        // 7-second full cycle through cool↔warm hues, but with lower saturation/value
        float cycle = 6.2831853 / 7.0;
        float hue   = fract((uTime + uIriPhase) * cycle * 0.16);
        // Mixed cool/warm but desaturated for realism
        vec3 iri = hsv2rgb(vec3(hue, 0.45, 0.85));

        // Base body color (already muted); add subtle darkening toward belly/back via vUv.y
        float band = 0.25 + 0.75*smoothstep(0.0, 1.0, vUv.y); // simple vertical gradient
        vec3 base = uBaseColor * mix(0.9, 1.05, band);

        // Combine terms (reduced saturation & energy for realism)
        float pulse = 0.5 + 0.5*sin((uTime + uIriPhase)*cycle*0.9);
        vec3 color = base * (0.85 + 0.15*scaleMask)               // slight cell modulation
                   + iri  * (scaleMask * (0.18*fres + 0.10*pulse)); // tempered highlight

        // Gentle specular sheen
        float spec = pow(max(dot(reflect(-V,N), V), 0.0), 24.0);
        color += 0.08 * spec;

        // Very light global desaturation for camera realism
        float g = dot(color, vec3(0.299,0.587,0.114));
        color = mix(color, vec3(g), 0.08);

        gl_FragColor = vec4(color, uOpacity);
      }
    `;

    function makeFishBodyMaterial(baseHex, iriPhase){
      const mat = new THREE.ShaderMaterial({
        vertexShader: fishVertexShader,
        fragmentShader: fishFragmentShader,
        transparent: true,
        uniforms: {
          uTime:      { value: 0 },
          uOpacity:   { value: 1 },
          uBaseColor: { value: new THREE.Color(baseHex) },
          uViewPos:   { value: new THREE.Vector3() },
          uIriPhase:  { value: iriPhase },
          uTailPhase: { value: Math.random()*Math.PI*2 }
        }
      });
      return mat;
    }

    /* ===== Fins/tails (translucent with faint blue rim) ===== */
    function finMaterial(baseHex){
      const col = new THREE.Color(baseHex).lerp(new THREE.Color('#ffffff'), 0.35);
      return new THREE.MeshStandardMaterial({
        color: col,
        roughness: 0.55,
        metalness: 0.08,
        emissive: new THREE.Color(0x355cff),
        emissiveIntensity: 0.14,
        transparent: true,
        opacity: 0.55,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
    }
    const eyeMaterial = ()=> new THREE.MeshBasicMaterial({ color:0x000000, transparent:true, opacity:1 });

    /* ===== Fish model (elegant) ===== */
    function createFishModel(hex){
      const group = new THREE.Group();

      // Body with shader
      const bodyGeo = new THREE.SphereGeometry(0.36, 28, 20);
      const bodyMat = makeFishBodyMaterial(hex, Math.random()*10.0);
      const body = new THREE.Mesh(bodyGeo, bodyMat);
      body.scale.set(1.9, 1.0, 0.85);
      group.add(body);

      // Forked tail (two long ribbons)
      const tailMat = finMaterial(hex);
      const tailGeo = new THREE.PlaneGeometry(0.8, 0.55, 1, 5);
      const tailL = new THREE.Mesh(tailGeo, tailMat);
      const tailR = new THREE.Mesh(tailGeo, tailMat.clone());
      tailL.position.set(-1.02, 0,  0.12);
      tailR.position.set(-1.02, 0, -0.12);
      tailL.rotation.y = tailR.rotation.y = Math.PI*0.5;
      group.add(tailL, tailR);

      // Long dorsal/ventral
      const longFinGeo = new THREE.PlaneGeometry(1.0, 0.3, 1, 5);
      const finTop = new THREE.Mesh(longFinGeo, finMaterial(hex));
      const finBot = new THREE.Mesh(longFinGeo, finMaterial(hex));
      finTop.position.set(0.1,  0.24, 0.0);  finTop.rotation.x = -Math.PI/12;
      finBot.position.set(0.05, -0.24, 0.0); finBot.rotation.x =  Math.PI/12;
      group.add(finTop, finBot);

      // Pectorals
      const pecGeo = new THREE.PlaneGeometry(0.45, 0.2, 1, 2);
      const pecL = new THREE.Mesh(pecGeo, finMaterial(hex));
      const pecR = new THREE.Mesh(pecGeo, finMaterial(hex));
      pecL.position.set(0.28,-0.08, 0.33); pecR.position.set(0.28,-0.08,-0.33);
      pecL.rotation.set(0,  Math.PI/2.6,  Math.PI/12);
      pecR.rotation.set(0, -Math.PI/2.6, -Math.PI/12);
      group.add(pecL, pecR);

      // Eyes
      const eyeGeo = new THREE.SphereGeometry(0.04, 12, 12);
      const eyeL = new THREE.Mesh(eyeGeo, eyeMaterial());
      const eyeR = eyeL.clone();
      eyeL.position.set(0.55, 0.08,  0.18);
      eyeR.position.set(0.55, 0.08, -0.18);
      group.add(eyeL, eyeR);

      // Mouth (deep red, larger than eyes, flush with head)
      const mouth = new THREE.Mesh(
        new THREE.CircleGeometry(0.075, 24),
        new THREE.MeshBasicMaterial({ color: 0xaa2222, transparent:true, opacity:1 })
      );
      mouth.position.set(0.72, 0.02, 0.0);
      mouth.rotation.y = Math.PI/2;
      group.add(mouth);

      group.userData = { body, bodyMat, tailL, tailR, finTop, finBot, pecL, pecR, eyes:[eyeL,eyeR], mouth };
      return group;
    }

    /* ===== Fish behavior (calm drift) ===== */
    const BOUNDS={x:5.8,y:2.9,z:3.8};

    class Fish{
      constructor(hex){
        this.group = createFishModel(hex);
        this.thought = makeBubbleSprite(choose(PHRASES));
        this.thought.position.set(0,0.95,0);
        this.group.add(this.thought);

        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel = new THREE.Vector3(rand(-0.01,0.01), rand(-0.005,0.005), rand(-0.008,0.008));
        this.speed = rand(0.003, 0.010);
        this.dead=false;

        this.tailPhase=Math.random()*Math.PI*2;
        this.finPhase =Math.random()*Math.PI*2;
        this.mouthPhase=Math.random()*Math.PI*2;
        this.driftPhase=Math.random()*Math.PI*2;
        this.heading=0;

        scene.add(this.group);
      }

      fade(){
        if(this.dead) return; this.dead=true;
        this.group.remove(this.thought); scene.remove(this.thought);
        const farewell=makeBubbleSprite("i will remember this.");
        farewell.position.copy(this.group.position).add(new THREE.Vector3(0,0.9,0));
        scene.add(farewell);

        const start=performance.now();
        const fadeOut=()=>{
          const t=(performance.now()-start)/1500;
          this.group.userData.bodyMat.uniforms.uOpacity.value=clamp(1-t,0,1);
          this.group.traverse(o=>{
            if(o.material && o.material!==this.group.userData.bodyMat){
              if('opacity' in o.material) o.material.opacity=clamp(1-t,0,1);
            }
          });
          if(t<1) requestAnimationFrame(fadeOut); else scene.remove(this.group);
        }; fadeOut();

        const msgStart=performance.now();
        const msgAnim=()=>{
          const t=(performance.now()-msgStart)/4000;
          farewell.position.y+=0.002;
          farewell.material.opacity=clamp(1-t,0,1);
          if(t<1) requestAnimationFrame(msgAnim); else scene.remove(farewell);
        }; msgAnim();
      }

      update(dt,time){
        if(this.dead) return;
        const UD=this.group.userData;

        // Calm drift (very gentle)
        this.vel.x += Math.sin(time*0.5 + this.driftPhase)*0.0025;
        this.vel.y += Math.cos(time*0.4 + this.driftPhase)*0.0007;
        this.vel.z += Math.sin(time*0.37+ this.driftPhase)*0.0012;

        // Subtle mouse avoidance in short radius
        const toMouse=new THREE.Vector3().subVectors(this.group.position,mouseWorld);
        const dist=toMouse.length(); const radius=1.4;
        if(Number.isFinite(dist)&&dist<radius){
          const s=(radius-dist)/radius; toMouse.normalize();
          this.vel.addScaledVector(toMouse, s*0.012);
        }

        // Damping & speed clamp
        this.vel.multiplyScalar(0.988);
        if(this.vel.length()>this.speed) this.vel.setLength(this.speed);

        // Move
        this.group.position.addScaledVector(this.vel, dt*60);

        // Soft bounds
        const p=this.group.position, v=this.vel;
        if(p.x<-BOUNDS.x){p.x=-BOUNDS.x; v.x=Math.abs(v.x)*0.8;}
        if(p.x> BOUNDS.x){p.x= BOUNDS.x; v.x=-Math.abs(v.x)*0.8;}
        if(p.y<-BOUNDS.y){p.y=-BOUNDS.y; v.y=Math.abs(v.y)*0.8;}
        if(p.y> BOUNDS.y){p.y= BOUNDS.y; v.y=-Math.abs(v.y)*0.8;}
        if(p.z<-BOUNDS.z){p.z=-BOUNDS.z; v.z=Math.abs(v.z)*0.8;}
        if(p.z> BOUNDS.z){p.z= BOUNDS.z; v.z=-Math.abs(v.z)*0.8;}

        // Smooth heading
        const dir=this.vel.clone().normalize();
        if(dir.lengthSq()>0.00001){
          const targetYaw=Math.atan2(-dir.z, dir.x);
          this.heading=lerpAngle(this.heading,targetYaw,clamp(2.1*dt,0,1));
          this.group.rotation.y=this.heading;
          this.group.rotation.z=Math.sin(time*0.7 + this.tailPhase)*0.03;
        }

        // Fins/tail wobble
        const tailAngle=Math.sin(time*2.0 + this.tailPhase)*THREE.MathUtils.degToRad(10);
        UD.tailL.rotation.z= tailAngle;
        UD.tailR.rotation.z=-tailAngle;
        const finAng=Math.sin(time*1.6 + this.finPhase)*THREE.MathUtils.degToRad(5);
        UD.finTop.rotation.z= finAng;
        UD.finBot.rotation.z=-finAng;
        const pecAng=Math.sin(time*2.2 + this.finPhase)*THREE.MathUtils.degToRad(6);
        UD.pecL.rotation.x= pecAng*0.5;
        UD.pecR.rotation.x=-pecAng*0.5;

        // Mouth breathing
        const mouthOpen=(Math.sin(time*2.0 + this.mouthPhase)*0.5+0.5)*0.25 + 0.9;
        UD.mouth.scale.set(1, mouthOpen, 1);

        // Shader uniforms
        UD.bodyMat.uniforms.uTime.value=time;
        UD.bodyMat.uniforms.uViewPos.value.copy(camera.position);

        this.thought.lookAt(camera.position);
      }
    }

    /* ===== Realistic muted palette (distinct but natural) ===== */
    const REAL_BASES = [
      '#7b8f96', // slate blue-gray
      '#8ea79a', // silvery green
      '#6f8591', // steel blue
      '#9aa78f', // olive-silver
      '#5f7c8f', // deep blue-gray
      '#91a6b6', // pale steel
      '#7a8a72', // muted olive
      '#a3b2ad', // light sea-gray
      '#6c7e8b', // blue cod
      '#8fa3a7', // greenish silver
      '#7c8da0', // cool gray-blue
      '#96a7a0', // soft seafoam gray
      '#7a8b78', // kelp olive
      '#8aa0b0'  // mist blue
    ];

    const FISH=[]; for(let i=0;i<14;i++) FISH.push(new Fish(REAL_BASES[i % REAL_BASES.length]));

    /* ===== Click-to-fade ===== */
    addEventListener('click', e=>{
      mouseNDC.x=(e.clientX/innerWidth)*2-1;
      mouseNDC.y=-(e.clientY/innerHeight)*2+1;
      raycaster.setFromCamera(mouseNDC,camera);
      const candidates=[]; for(const f of FISH){ f.group.traverse(o=>{ if(o.isMesh) candidates.push(o); }); }
      const hits=raycaster.intersectObjects(candidates,true);
      if(hits.length){
        const fish=FISH.find(ff=>{ let hit=false; ff.group.traverse(o=>{ if(o===hits[0].object) hit=true; }); return hit; });
        if(fish) fish.fade();
      }
    });

    /* ===== Floating water bubbles ===== */
    const bubbleCount=220, bubbleGeo=new THREE.BufferGeometry();
    const bPos=new Float32Array(bubbleCount*3), bSpeed=new Float32Array(bubbleCount);
    for(let i=0;i<bubbleCount;i++){
      bPos[i*3]=rand(-6,6); bPos[i*3+1]=rand(-3,3); bPos[i*3+2]=rand(-4,4);
      bSpeed[i]=rand(0.12,0.45);
    }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(bPos,3));
    const bubbleMat=new THREE.PointsMaterial({ color:0xdff9ff, size:0.06, transparent:true, opacity:0.7, depthWrite:false, blending:THREE.AdditiveBlending });
    const bubbles=new THREE.Points(bubbleGeo,bubbleMat); scene.add(bubbles);
    function updateBubbles(dt){
      const arr=bubbleGeo.attributes.position.array;
      for(let i=0;i<bubbleCount;i++){
        arr[i*3+1]+=bSpeed[i]*dt;
        if(arr[i*3+1]>3.2){ arr[i*3+1]=-3.2; arr[i*3]=rand(-6,6); arr[i*3+2]=rand(-4,4); }
      }
      bubbleGeo.attributes.position.needsUpdate=true;
    }

    /* ===== Shark (PNG plane behind fish) ===== */
    const SHARK_SRC='shark.png';
    class Shark{
      constructor(){
        this.dir=1; this.speed=0.55;
        this.y=rand(0.2,1.2); this.z=-7.8;
        this.phase=Math.random()*Math.PI*2; this.flipBound=16.5;
        new THREE.TextureLoader().load(SHARK_SRC, t=>{
          t.colorSpace=THREE.SRGBColorSpace; t.premultiplyAlpha=true;
          const aspect=t.image.width/t.image.height, W=19, H=W/aspect;
          const m=new THREE.MeshBasicMaterial({ map:t, transparent:true, opacity:0.75, depthWrite:false, side:THREE.DoubleSide, alphaTest:0.03 });
          this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(W,H),m);
          this.mesh.position.set(-this.flipBound-0.2,this.y,this.z);
          scene.add(this.mesh);
        });
      }
      update(dt,t){
        if(!this.mesh) return;
        this.mesh.position.x+=this.dir*this.speed*dt;
        this.mesh.position.y=this.y+Math.sin(t*0.25+this.phase)*0.12;
        if(this.dir>0 && this.mesh.position.x> this.flipBound){ this.dir=-1; this.mesh.rotation.y=Math.PI; }
        else if(this.dir<0 && this.mesh.position.x<-this.flipBound){ this.dir= 1; this.mesh.rotation.y=0; }
      }
    }
    const SHARK=new Shark();

    /* ===== Resize ===== */
    addEventListener('resize', ()=>{
      camera.aspect=innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth,innerHeight);
    });

    /* ===== Animate ===== */
    let last=performance.now();
    function tick(now){
      const dt=Math.min((now-last)/1000,0.05); last=now;
      const t=now*0.001;

      const targetX=mouseX*panRange;
      camera.position.x+=(targetX-camera.position.x)*0.05;
      camera.lookAt(0,0,0);

      for(const f of FISH) f.update(dt,t);
      updateBubbles(dt);
      SHARK.update(dt,t);

      renderer.render(scene,camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
