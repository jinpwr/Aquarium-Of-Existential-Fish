<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    /* Darker ocean gradient, top lighter → bottom darker, hue cycles green-blue→blue→blue-purple */
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #9ed3da 0%, #3d69b4 45%, #14063a 100%);
      background-attachment: fixed;
      animation: hueOcean 110s ease-in-out infinite;
    }
    @keyframes hueOcean {
      0%   { background: linear-gradient(to bottom, #9ed3da 0%, #3d69b4 45%, #14063a 100%); }   /* green-blue */
      50%  { background: linear-gradient(to bottom, #8bbce2 0%, #425dcb 45%, #140a45 100%); }   /* blue */
      100% { background: linear-gradient(to bottom, #9ed3da 0%, #3d69b4 45%, #14063a 100%); }   /* blue-purple return */
    }

    canvas { display:block }

    /* subtle film grain */
    #dither{
      position:fixed; inset:0; pointer-events:none; opacity:.12; z-index:1;
      background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="black" opacity="0"/><rect x="0" y="0" width="2" height="2" fill="white" opacity="0.07"/><rect x="2" y="2" width="2" height="2" fill="white" opacity="0.07"/></svg>');
      image-rendering:pixelated; background-size:4px; background-repeat:repeat; mix-blend-mode:overlay;
    }

    #overlay{
      position:fixed; inset:0; pointer-events:none; z-index:3;
      display:flex; align-items:flex-end; justify-content:flex-end;
      padding: 12px 14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#b3f4ff; text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{ font-weight:700; letter-spacing:.5px; font-size:12px; color:#9effc7; }
  </style>
</head>
<body>
  <div id="dither"></div>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /* === Scene === */
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0e0830, 0.06);

    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, premultipliedAlpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.6;   // a touch brighter so fish pop
    document.body.appendChild(renderer.domElement);

    /* === Lighting (cool blue, oriented to highlight fish from front-right) === */
    const hemi = new THREE.HemisphereLight(0xbfeaff, 0x0f1033, 0.7);        // cool sky + deep seafloor
    const key  = new THREE.PointLight(0x7cd9ff, 26, 120, 1.8); key.position.set(5, 4, 6);  // front-right, bright
    const fill = new THREE.PointLight(0x6ff0d4, 10, 120, 1.8); fill.position.set(-5, 1.2, 5); // soft fill from left
    const rim  = new THREE.PointLight(0x6b6bff, 16, 160, 2.2); rim.position.set(0, 3.6, -9);  // cool rim from back
    scene.add(hemi, key, fill, rim);

    /* === Helpers === */
    const rand = (a,b)=> a + Math.random()*(b-a);
    const choose = arr => arr[(Math.random()*arr.length)|0];

    /* === Mouse world position (avoidance) & horizontal pan === */
    const raycaster = new THREE.Raycaster();
    const mouseNDC = new THREE.Vector2(0,0);
    const avoidPlaneZ = 0;
    const plane = new THREE.Plane(new THREE.Vector3(0,0,1), -avoidPlaneZ);
    const mouseWorld = new THREE.Vector3(999,999,0); // start far away
    let mouseX = 0;                 // [-1, 1]
    const panRange = 1.4;           // stronger pan for depth

    addEventListener('mousemove', (e)=>{
      mouseX = (e.clientX / innerWidth) * 2 - 1;
      mouseNDC.x = mouseX;
      mouseNDC.y = -(e.clientY / innerHeight) * 2 + 1;
      raycaster.setFromCamera(mouseNDC, camera);
      raycaster.ray.intersectPlane(plane, mouseWorld);
    });

    /* === Thought bubbles === */
    const PHRASES = [
      'i am not real','today i forgot myself','be kind to the void','do fish dream?',
      '404: meaning not found','blink slowly','pretend to be water','becoming … becoming','a small thought floats'
    ];
    function makeBubbleSprite(text){
      const w=256,h=128;
      const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h;
      const ctx=cvs.getContext('2d');
      ctx.fillStyle='rgba(0,0,0,0.24)';
      ctx.strokeStyle='rgba(220,255,250,0.75)'; ctx.lineWidth=2;
      roundRect(ctx,8,8,w-16,h-16,14,true,true);
      ctx.font='600 22px ui-monospace, monospace';
      ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
      wrapText(ctx,text,w/2,h/2,w-36,28);
      const tex=new THREE.CanvasTexture(cvs);
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false });
      const spr=new THREE.Sprite(mat); spr.scale.set(2.2,1.1,1);
      spr.userData={canvas:cvs,ctx,texture:tex};
      return spr;
    }
    function updateBubbleText(sprite, text){
      const { canvas:cvs, ctx, texture:tex } = sprite.userData;
      const w=cvs.width,h=cvs.height;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle='rgba(0,0,0,0.24)';
      ctx.strokeStyle='rgba(220,255,250,0.75)'; ctx.lineWidth=2;
      roundRect(ctx,8,8,w-16,h-16,14,true,true);
      ctx.font='600 22px ui-monospace, monospace';
      ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
      wrapText(ctx,text,w/2,h/2,w-36,28);
      tex.needsUpdate=true;
    }
    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      if(fill)ctx.fill();
      if(stroke)ctx.stroke();
    }
    function wrapText(ctx,text,x,y,maxWidth,lineHeight){
      const words=text.split(' '); const lines=[]; let line='';
      for(const w of words){
        const test=line?line+' '+w:w;
        if(ctx.measureText(test).width>maxWidth){ lines.push(line); line=w; } else line=test;
      }
      if(line)lines.push(line);
      const total=lines.length*lineHeight; let curY=y-total/2+lineHeight/2;
      for(const l of lines){ ctx.fillText(l,x,curY); curY+=lineHeight; }
    }

    /* === Procedural fish textures (subtle, naturalistic) === */
    const NATURAL_BASES = ['#d9e1e8', '#9bb3a1', '#74a6b3', '#e2b35a', '#e39b7a']; // silver, olive-silver, teal, gold, coral

    function canvasFishTexture(seedHex){
      const w = 512, h = 256;
      const c = document.createElement('canvas'); c.width = w; c.height = h;
      const ctx = c.getContext('2d');

      // vertical gradient body (belly lighter)
      const g = ctx.createLinearGradient(0, 0, 0, h);
      const base = new THREE.Color(seedHex);
      const belly = base.clone().lerp(new THREE.Color('#ffffff'), 0.40);
      const back  = base.clone().lerp(new THREE.Color('#1b1f2a'), 0.22);
      g.addColorStop(0.00, `#${belly.getHexString()}`);
      g.addColorStop(0.55, `#${base.getHexString()}`);
      g.addColorStop(1.00, `#${back.getHexString()}`);
      ctx.fillStyle = g; ctx.fillRect(0,0,w,h);

      // faint lateral line
      ctx.strokeStyle = 'rgba(255,255,255,0.28)';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(0, h*0.56);
      for (let x=0; x<=w; x+=18){
        const y = h*0.56 + Math.sin(x*0.02)*1.8;
        ctx.lineTo(x, y);
      }
      ctx.stroke();

      // very subtle soft stripes
      ctx.globalAlpha = 0.06;
      for (let x=0; x<w; x+=20){
        const fade = (Math.sin(x*0.035)+1)/2 * 0.5 + 0.2;
        ctx.fillStyle = `rgba(255,255,255,${fade})`;
        ctx.fillRect(x, 0, 6, h);
      }
      ctx.globalAlpha = 1;

      // tiny speckles
      const speck = ctx.createImageData(w, h);
      for (let i=0; i<w*h; i+=18){
        const xx = (i % w), yy = ((i / w)|0);
        const k = (yy*w + xx) * 4;
        const a = Math.random()*18 | 0;
        speck.data[k+0] = 255;
        speck.data[k+1] = 255;
        speck.data[k+2] = 255;
        speck.data[k+3] = a;
      }
      ctx.putImageData(speck, 0, 0);

      const tex = new THREE.CanvasTexture(c);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
      return tex;
    }

    function makeMatFromCanvas(seedHex){
      const tex = canvasFishTexture(seedHex);
      return new THREE.MeshStandardMaterial({
        map: tex,
        color: 0xffffff,          // keep texture colors true
        roughness: 0.35,
        metalness: 0.28,
        emissive: new THREE.Color(0x1a1a1a), // tiny base lift so they don’t crush to black
        emissiveIntensity: 0.25,
        flatShading: true
      });
    }

    function makeFishMesh(){
      const g = new THREE.Group();
      const baseHex = choose(NATURAL_BASES);
      const bodyMat = makeMatFromCanvas(baseHex);
      const finMat  = new THREE.MeshStandardMaterial({
        color: new THREE.Color(baseHex).lerp(new THREE.Color('#ffffff'), 0.18),
        roughness: 0.55, metalness: 0.2, flatShading: true
      });

      const bodyGeo = new THREE.IcosahedronGeometry(rand(0.25,0.38), 0);
      bodyGeo.scale(rand(1.6,2.1), 1, 1);
      const body = new THREE.Mesh(bodyGeo, bodyMat); g.add(body);

      const tailGeo = new THREE.ConeGeometry(0.2, 0.35, 3);
      tailGeo.rotateZ(Math.PI/2); tailGeo.translate(-bodyGeo.parameters.radius*1.1, 0, 0);
      const tail = new THREE.Mesh(tailGeo, finMat); g.add(tail);

      const finGeo = new THREE.ConeGeometry(0.08, 0.18, 3);
      const finL = new THREE.Mesh(finGeo, finMat);
      const finR = new THREE.Mesh(finGeo, finMat.clone());
      finL.position.set(0.1, -0.1, 0.18); finL.rotation.z = -Math.PI/3;
      finR.position.set(0.1, -0.1, -0.18); finR.rotation.z = -Math.PI/3; finR.rotation.y = Math.PI;
      g.add(finL, finR);

      const eyeGeo = new THREE.SphereGeometry(0.04, 12, 12);
      const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.12, metalness: 0.35 });
      const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
      const eyeR = new THREE.Mesh(eyeGeo, eyeMat);
      eyeL.position.set(0.4, 0.06, 0.12); eyeR.position.set(0.4, 0.06, -0.12);
      g.add(eyeL, eyeR);

      return g;
    }

    /* === Fish with bounds + stronger mouse avoidance === */
    const BOUNDS = { x: 5.8, y: 2.9, z: 3.8 };

    class Fish{
      constructor(){
        this.group = new THREE.Group();
        this.mesh  = makeFishMesh(); this.group.add(this.mesh);
        this.bubble = makeBubbleSprite(choose(PHRASES)); this.bubble.position.set(0,0.9,0);
        this.group.add(this.bubble);

        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel  = new THREE.Vector3(rand(-0.02,0.02), rand(-0.01,0.01), rand(-0.015,0.015));
        this.turn = new THREE.Vector3(rand(-0.001,0.001), rand(-0.001,0.001), rand(-0.001,0.001));
        this.speed = rand(0.004, 0.018);
        scene.add(this.group);
      }
      update(dt){
        // wander
        this.vel.addScaledVector(this.turn, dt).clampLength(0, this.speed);

        // stronger avoidance
        const toMouse = new THREE.Vector3().subVectors(this.group.position, mouseWorld);
        const dist = toMouse.length();
        const influenceRadius = 3.5;         // was 1.8
        if (isFinite(dist) && dist < influenceRadius){
          const strength = (influenceRadius - dist) / influenceRadius; // 0..1
          toMouse.normalize();
          this.vel.addScaledVector(toMouse, strength * 0.06);  // was 0.03
        }

        // move
        this.group.position.addScaledVector(this.vel, dt * 60);

        // keep inside bounds
        const p = this.group.position, v = this.vel;
        if (p.x < -BOUNDS.x){ p.x = -BOUNDS.x; v.x = Math.abs(v.x); }
        if (p.x >  BOUNDS.x){ p.x =  BOUNDS.x; v.x = -Math.abs(v.x); }
        if (p.y < -BOUNDS.y){ p.y = -BOUNDS.y; v.y = Math.abs(v.y); }
        if (p.y >  BOUNDS.y){ p.y =  BOUNDS.y; v.y = -Math.abs(v.y); }
        if (p.z < -BOUNDS.z){ p.z = -BOUNDS.z; v.z = Math.abs(v.z); }
        if (p.z >  BOUNDS.z){ p.z =  BOUNDS.z; v.z = -Math.abs(v.z); }

        // face swim direction
        const dir = this.vel.clone().normalize();
        if (dir.lengthSq() > 0.0001){
          const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dir);
          this.group.quaternion.slerp(targetQuat, 0.1);
        }

        // fin wiggle & bubble billboard
        this.mesh.children.forEach(c=>{ if(c.geometry && c.geometry.type==='ConeGeometry'){ c.rotation.y += 0.04; }});
        this.bubble.lookAt(camera.position);
      }
      randomThought(){ updateBubbleText(this.bubble, choose(PHRASES)); }
    }

    const FISH=[]; for(let i=0;i<18;i++) FISH.push(new Fish());
    setInterval(()=>{ const f = choose(FISH); if (f) f.randomThought(); }, 2200);

    /* === Floating water bubbles === */
    const bubbleCount=220;
    const bubbleGeo=new THREE.BufferGeometry();
    const positions=new Float32Array(bubbleCount*3);
    const speeds=new Float32Array(bubbleCount);
    const xDrifts=new Float32Array(bubbleCount);
    for(let i=0;i<bubbleCount;i++){
      positions[i*3+0]=rand(-6,6);
      positions[i*3+1]=rand(-3,3);
      positions[i*3+2]=rand(-4,4);
      speeds[i]=rand(0.12,0.45);
      xDrifts[i]=rand(-0.15,0.15);
    }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
    const bubbleMat=new THREE.PointsMaterial({
      color:0xdff9ff, size:0.06, sizeAttenuation:true, transparent:true, opacity:0.7,
      depthWrite:false, blending:THREE.AdditiveBlending
    });
    const bubbles=new THREE.Points(bubbleGeo,bubbleMat); scene.add(bubbles);
    function updateBubbles(dt){
      const arr=bubbleGeo.attributes.position.array;
      for(let i=0;i<bubbleCount;i++){
        let x=arr[i*3+0], y=arr[i*3+1], z=arr[i*3+2];
        y += speeds[i]*dt; x += xDrifts[i]*dt*0.4;
        if(y>3.2){ y=-3.2; x=rand(-6,6); z=rand(-4,4);
          speeds[i]=rand(0.12,0.45); xDrifts[i]=rand(-0.15,0.15);
        }
        arr[i*3+0]=x; arr[i*3+1]=y; arr[i*3+2]=z;
      }
      bubbleGeo.attributes.position.needsUpdate=true;
    }

    /* === Shark: 2× size, 75% transparent, flips far offscreen === */
    const SHARK_SRC='shark.png';
    function loadSharkTexture(cb){
      const loader=new THREE.TextureLoader();
      loader.load(SHARK_SRC, t=>{
        t.colorSpace=THREE.SRGBColorSpace; t.premultiplyAlpha=true;
        t.generateMipmaps=false; t.minFilter=THREE.LinearFilter; t.magFilter=THREE.LinearFilter;
        t.needsUpdate=true; cb(t);
      }, undefined, ()=>cb(null));
    }
    class Shark {
      constructor(){
        this.mesh=null; this.dir=1; this.speed=0.55;
        this.y=rand(0.2,1.2); this.z=-7.8; this.phase=Math.random()*Math.PI*2;
        this.flipBound=16.5;
        loadSharkTexture(tex=>{
          if(!tex) return;
          const aspect = tex.image.width / tex.image.height;
          const W = 9.5 * 2, H = W / aspect;
          const mat = new THREE.MeshBasicMaterial({
            map:tex, transparent:true, opacity:0.9*0.75, depthWrite:false,
            side:THREE.DoubleSide, alphaTest:0.03
          });
          this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(W,H), mat);
          this.mesh.position.set(-this.flipBound - 0.2, this.y, this.z);
          this.mesh.rotation.y = 0;
          scene.add(this.mesh);
        });
      }
      update(dt,t){
        if(!this.mesh) return;
        this.mesh.position.x += this.dir * this.speed * dt;
        this.mesh.position.y  = this.y + Math.sin(t*0.25 + this.phase) * 0.12;
        if(this.dir>0 && this.mesh.position.x >  this.flipBound){ this.dir=-1; this.mesh.rotation.y=Math.PI; }
        else if(this.dir<0 && this.mesh.position.x < -this.flipBound){ this.dir= 1; this.mesh.rotation.y=0; }
      }
    }
    const SHARK = new Shark();

    /* === Resize === */
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* === Animate === */
    let last = performance.now();
    function tick(now){
      const dt = Math.min((now - last)/1000, 0.05); last = now;
      const t = now * 0.001;

      // horizontal camera pan for depth
      const targetX = mouseX * panRange;
      camera.position.x += (targetX - camera.position.x) * 0.05;
      camera.lookAt(0,0,0);

      for(const f of FISH) f.update(dt);
      updateBubbles(dt);
      SHARK.update(dt,t);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);

    /* === Create fish after functions are defined === */
    const FISH=[]; for(let i=0;i<18;i++) FISH.push(new Fish());
    setInterval(()=>{ const f = FISH[(Math.random()*FISH.length)|0]; if (f) f.randomThought(); }, 2200);
  </script>
</body>
</html>
