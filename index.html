<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      /* Realistic ocean gradient; JS pulses brightness only (no hue change) */
      background: linear-gradient(to bottom,
        hsl(195 60% 34%) 0%,
        hsl(210 60% 22%) 45%,
        hsl(220 60% 10%) 100%
      );
    }
    canvas { display:block }

    #dither{
      position:fixed; inset:0; pointer-events:none; opacity:.12; z-index:2;
      background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="black" opacity="0"/><rect x="0" y="0" width="2" height="2" fill="white" opacity="0.07"/><rect x="2" y="2" width="2" height="2" fill="white" opacity="0.07"/></svg>');
      image-rendering:pixelated; background-size:4px; background-repeat:repeat; mix-blend-mode:overlay;
    }

    #overlay{
      position:fixed; inset:0; pointer-events:none; z-index:4;
      display:flex; align-items:flex-end; justify-content:flex-end;
      padding: 12px 14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#b3f4ff; text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{ font-weight:700; letter-spacing:.5px; font-size:12px; color:#9effc7; }

    #instructions{
      position:fixed; left:12px; bottom:10px; z-index:4; pointer-events:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px; line-height:1.5;
      color:#9effc7; text-shadow:0 1px 2px rgba(0,0,0,.3);
      white-space:pre-line;
    }
  </style>
</head>
<body>
  <div id="dither"></div>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>
  <div id="instructions">move mouse horizontally to look around / try clicking on a fish</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /* ===== Scene / Renderer ===== */
    const scene = new THREE.Scene();
    const world = new THREE.Group();
    scene.add(world);
    scene.fog = new THREE.FogExp2(0x0e0a2a, 0.05);

    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, premultipliedAlpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.9;
    document.body.appendChild(renderer.domElement);

    /* ===== Lights ===== */
    const hemi = new THREE.HemisphereLight(0xaad9ff, 0x0b0018, 0.35);
    const key  = new THREE.DirectionalLight(0xb0d6ff, 1.45); key.position.set(4, 6, 2);
    const fill = new THREE.DirectionalLight(0x66ffd2, 0.35);  fill.position.set(-5, 2, -3);
    const rim  = new THREE.DirectionalLight(0x8b86ff, 0.9);   rim.position.set(0, 3.5, -6);
    scene.add(hemi, key, fill, rim);

    /* ===== Helpers ===== */
    const rand = (a,b)=> a + Math.random()*(b-a);
    const choose = arr => arr[(Math.random()*arr.length)|0];

    /* ===== Ocean brightness pulsing (no hue shift) ===== */
    function updateBackground(nowMs){
      const t = nowMs * 0.001;
      const k = Math.sin(t * 0.25) * 6; // % lightness swing
      const L1 = 34 + k, L2 = 22 + k*0.8, L3 = 10 + k*0.6;
      document.body.style.background =
        `linear-gradient(to bottom,
          hsl(195 60% ${L1}%) 0%,
          hsl(210 60% ${L2}%) 45%,
          hsl(220 60% ${L3}%) 100%
        )`;
    }

    /* ===== Soft God Rays ===== */
    function makeGodRay(){
      const geo = new THREE.ConeGeometry(6.5, 16, 64, 1, true);
      geo.rotateX(-Math.PI/2);
      const mat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{ uTime:{value:0}, uTint:{value:new THREE.Color(0xbfe8ff)}, uOpacity:{value:0.16} },
        vertexShader:/*glsl*/`
          precision highp float;
          varying vec2 vUv;
          void main(){
            vUv=uv;
            gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0);
          }
        `,
        fragmentShader:/*glsl*/`
          precision highp float;
          varying vec2 vUv;
          uniform vec3 uTint;
          uniform float uTime,uOpacity;
          void main(){
            float r = 1.0 - vUv.y;
            float radial = smoothstep(0.0,0.6,r)*(1.0 - smoothstep(0.6,1.0,r));
            float band = 0.5 + 0.5*sin(vUv.x*22.0 + uTime*0.4);
            float alpha = radial * (0.35 + 0.65*band);
            alpha *= (1.0 - vUv.x*0.6);
            alpha *= uOpacity;
            if(alpha < 0.01) discard;
            gl_FragColor = vec4(uTint, alpha);
          }
        `
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.set(rand(-2,2), 5.8, rand(-1.5,1.5));
      m.rotation.z = rand(-0.15,0.15);
      m.userData.speed = rand(0.3, 0.7);
      return m;
    }
    const RAYS = []; for(let i=0;i<4;i++){ const r=makeGodRay(); RAYS.push(r); world.add(r); }

    /* ===== Speech bubbles ===== */
    function makeBubbleSprite(text){
      const w=256,h=128;
      const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h;
      const ctx=cvs.getContext('2d');
      ctx.fillStyle='rgba(0,0,0,0.24)';
      ctx.strokeStyle='rgba(220,255,250,0.75)'; ctx.lineWidth=2;
      roundRect(ctx,8,8,w-16,h-16,14,true,true);
      ctx.font='600 22px ui-monospace, monospace';
      ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
      wrapText(ctx,text,w/2,h/2,w-36,28);
      const tex=new THREE.CanvasTexture(cvs);
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false, opacity:1 });
      const spr=new THREE.Sprite(mat); spr.scale.set(2.2,1.1,1);
      spr.userData={canvas:cvs,ctx,texture:tex, material:mat};
      return spr;
    }
    function updateBubbleText(sprite, text){
      const { canvas:cvs, ctx, texture:tex } = sprite.userData;
      const w=cvs.width,h=cvs.height;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle='rgba(0,0,0,0.24)';
      ctx.strokeStyle='rgba(220,255,250,0.75)'; ctx.lineWidth=2;
      roundRect(ctx,8,8,w-16,h-16,14,true,true);
      ctx.font='600 22px ui-monospace, monospace';
      ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
      wrapText(ctx,text,w/2,h/2,w-36,28);
      tex.needsUpdate=true;
    }
    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      if(fill)ctx.fill();
      if(stroke)ctx.stroke();
    }
    function wrapText(ctx,text,x,y,maxWidth,lineHeight){
      const words=text.split(' '); const lines=[]; let line='';
      for(const w of words){
        const test=line?line+' '+w:w;
        if(ctx.measureText(test).width>maxWidth){ lines.push(line); line=w; } else line=test;
      }
      if(line)lines.push(line);
      const total=lines.length*lineHeight; let curY=y-total/2+lineHeight/2;
      for(const l of lines){ ctx.fillText(l,x,curY); curY+=lineHeight; }
    }

    /* ===== Rainbow sheen palette ===== */
    function hslToHex(h,s,l){
      const c=(1-Math.abs(2*l-1))*s, x=c*(1-Math.abs(((h*6)%2)-1)), m=l-c/2;
      let r=0,g=0,b=0;
      if(0<=h&&h<1/6){ r=c; g=x; b=0; }
      else if(h<2/6){ r=x; g=c; b=0; }
      else if(h<3/6){ r=0; g=c; b=x; }
      else if(h<4/6){ r=0; g=x; b=c; }
      else if(h<5/6){ r=x; g=0; b=c; }
      else { r=c; g=0; b=x; }
      const R=Math.round((r+m)*255), G=Math.round((g+m)*255), B=Math.round((b+m)*255);
      return (R<<16) | (G<<8) | B;
    }
    function rainbowSheenList(n){
      const arr=[];
      for(let i=0;i<n;i++){
        const h=i/n; // 0..1
        const hex=hslToHex(h,0.85,0.55);
        arr.push(new THREE.Color(hex));
      }
      return arr;
    }
    const RAINBOW_SHEENS = rainbowSheenList(32);

    /* ===== Fish shader: fine sand grain, dramatic light (FIX: declare cameraPosition) ===== */
    const FishSandMaterial = (sheenColor)=>{
      return new THREE.ShaderMaterial({
        transparent:true, depthWrite:true, fog:true,
        uniforms:{
          uLightDir: { value: new THREE.Vector3().copy(key.position) }, // will normalize in shader
          uDark:     { value: new THREE.Color(0x0e0e18) },
          uSheen:    { value: sheenColor.clone() },
          uOpacity:  { value: 1.0 },
          uTime:     { value: 0 },
          uGrain:    { value: 110.0 },
          uSpecPow:  { value: 90.0 },
          uRimPow:   { value: 2.2 },
          uRimStr:   { value: 0.42 }
        },
        vertexShader:/*glsl*/`
          precision highp float;
          varying vec3 vN;
          varying vec3 vW;
          varying vec2 vUv;
          void main(){
            vN = normalize(normalMatrix * normal);
            vec4 wp = modelMatrix * vec4(position,1.0);
            vW = wp.xyz;
            vUv = uv;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader:/*glsl*/`
          precision highp float;
          varying vec3 vN;
          varying vec3 vW;
          varying vec2 vUv;
          uniform vec3 uLightDir, uDark, uSheen;
          uniform float uOpacity, uTime, uGrain, uSpecPow, uRimPow, uRimStr;
          uniform vec3 cameraPosition;     // <-- REQUIRED for ShaderMaterial

          float hash(vec3 p){
            p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
            p += dot(p, p.yzx + 19.19);
            return fract((p.x+p.y)*p.z);
          }
          float grain(vec3 p){
            float g = hash(p*uGrain);
            g = mix(g, hash(p*uGrain*1.7), 0.5);
            g = mix(g, hash(p*uGrain*2.3 + vec3(uTime)), 0.35);
            return g;
          }

          void main(){
            vec3 N = normalize(vN);
            vec3 L = normalize(uLightDir - vW);      // use light POSITION → direction
            vec3 V = normalize(cameraPosition - vW); // now valid
            vec3 H = normalize(L + V);

            float ndotl = max(dot(N,L), 0.0);
            float diffuse = pow(ndotl, 1.25);

            float spec = pow(max(dot(N,H), 0.0), uSpecPow);
            float rim = pow(1.0 - max(dot(N,V), 0.0), uRimPow) * uRimStr;

            float g = grain(vW + vec3(0.0, uTime*0.15, 0.0));
            float grainDark = mix(0.68, 1.0, g);
            float grainLight = mix(0.85, 1.22, g);

            vec3 colDark = uDark * grainDark;
            vec3 colSheen = uSheen * (0.35 + 0.65*diffuse) * grainLight;

            vec3 color = mix(colDark, colSheen, diffuse);
            color += spec * (uSheen * 0.9 + vec3(0.08,0.1,0.12));
            color += rim * vec3(0.25, 0.28, 0.45);

            gl_FragColor = vec4(color, uOpacity);
            if(gl_FragColor.a < 0.02) discard;
          }
        `
      });
    };

    /* ===== UV helper ===== */
    function ensureSphericalUVs(geo){
      if(geo.attributes.uv) return;
      const pos = geo.attributes.position;
      const uv = new Float32Array((pos.count) * 2);
      const v = new THREE.Vector3();
      for(let i=0;i<pos.count;i++){
        v.fromBufferAttribute(pos, i).normalize();
        const u = 0.5 + Math.atan2(v.z, v.x) / (2*Math.PI);
        const w = 0.5 - Math.asin(v.y) / Math.PI;
        uv[i*2+0]=u; uv[i*2+1]=w;
      }
      geo.setAttribute('uv', new THREE.BufferAttribute(uv, 2));
      geo.attributes.uv.needsUpdate = true;
    }

    /* ===== Fish (tail fixed; rainbow hues; pause→fade with simultaneous memory bubble) ===== */
    const PHRASES = [
      'i am not real','today i forgot myself','be kind to the void','do fish dream?',
      '404: meaning not found','blink slowly','pretend to be water','becoming … becoming','a small thought floats'
    ];
    const BOUNDS = { x: 5.8, y: 2.9, z: 3.8 };

    function makeFishMesh(sheenColor){
      const g=new THREE.Group(); g.userData.isFish = true;

      // Body
      const radius = rand(0.25,0.38);
      const sx = rand(1.7, 2.2);
      const bodyGeo=new THREE.IcosahedronGeometry(radius, 0);
      bodyGeo.computeVertexNormals();
      bodyGeo.scale(sx, 1, 1);
      ensureSphericalUVs(bodyGeo);

      const bodyMat = FishSandMaterial(sheenColor);
      const body=new THREE.Mesh(bodyGeo, bodyMat); g.add(body);

      // Tail (base at pivot; tip flails outward)
      const tailLen = 0.42;
      const tailGeo=new THREE.ConeGeometry(0.20, tailLen, 7);
      tailGeo.translate(0, tailLen*0.5, 0);      // base at origin
      ensureSphericalUVs(tailGeo);
      const tailMat = FishSandMaterial(sheenColor);
      const tailMesh=new THREE.Mesh(tailGeo, tailMat);

      const tailPivot = new THREE.Group();
      tailPivot.add(tailMesh);
      tailPivot.rotation.z = Math.PI/2;          // +Y → -X
      const bodyMinX = -radius * sx;
      tailPivot.position.set(bodyMinX - 0.06, 0, 0);
      g.add(tailPivot);

      // Fins
      const finGeo=new THREE.ConeGeometry(0.08,0.18,7);
      finGeo.translate(0, 0.09, 0);
      ensureSphericalUVs(finGeo);
      const finMat = FishSandMaterial(sheenColor);
      const finL=new THREE.Mesh(finGeo,finMat);
      const finR=new THREE.Mesh(finGeo,finMat.clone());
      finL.rotation.z=-Math.PI/2.6; finR.rotation.z=-Math.PI/2.6; finR.rotation.y=Math.PI;
      finL.position.set(0.10,-0.05, 0.16);
      finR.position.set(0.10,-0.05,-0.16);
      g.add(finL,finR);

      // Eyes
      const eyeGeo=new THREE.SphereGeometry(0.038,12,12);
      const eyeMat=new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.25, metalness:0.1, transparent:true, opacity:1 });
      const eyeL=new THREE.Mesh(eyeGeo,eyeMat), eyeR=new THREE.Mesh(eyeGeo,eyeMat);
      eyeL.position.set(0.42,0.06,0.12); eyeR.position.set(0.42,0.06,-0.12); g.add(eyeL,eyeR);

      // Thought bubble
      const bubble=makeBubbleSprite(choose(PHRASES)); bubble.position.set(0,0.9,0); g.add(bubble);

      g.userData = {
        ...g.userData,
        body, tailPivot, tailMesh, fins:[finL,finR], eyes:[eyeL,eyeR], bubble,
        mats:[bodyMat, tailMat, finMat, finR.material],
      };
      return g;
    }

    class Fish{
      constructor(sheenColor){
        this.group=makeFishMesh(sheenColor); world.add(this.group);
        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel=new THREE.Vector3(rand(-0.02,0.02), rand(-0.01,0.01), rand(-0.015,0.015));
        this.turn=new THREE.Vector3(rand(-0.001,0.001), rand(-0.001,0.001), rand(-0.001,0.001));
        this.speed=rand(0.003,0.018);
        this.phase = Math.random()*Math.PI*2;

        this.paused = false;
        this.fading = false;
        this.fade = 1.0;
        this.pauseTimer = 0;

        this.memBubble = null; // spawned as fading starts
      }
      update(dt, t){
        if(!this.group) return;

        if(this.paused && !this.fading){
          this.pauseTimer += dt;
          if(this.pauseTimer >= 0.35){
            this.fading = true;
            if(!this.memBubble){
              const bubblePos = this.group.localToWorld(new THREE.Vector3(0,0.9,0));
              const mem = makeBubbleSprite('i will remember this.');
              mem.position.copy(bubblePos);
              world.add(mem);
              this.memBubble = mem;
            }
          }
        }

        if(!this.paused){
          this.vel.x += this.turn.x * dt; this.vel.y += this.turn.y * dt; this.vel.z += this.turn.z * dt;
          this.vel.clampLength(0, this.speed);
          this.group.position.addScaledVector(this.vel, dt * 60);
        }

        const p = this.group.position, v = this.vel;
        if (p.x < -BOUNDS.x){ p.x = -BOUNDS.x; v.x = Math.abs(v.x); }
        if (p.x >  BOUNDS.x){ p.x =  BOUNDS.x; v.x = -Math.abs(v.x); }
        if (p.y < -BOUNDS.y){ p.y = -BOUNDS.y; v.y = Math.abs(v.y); }
        if (p.y >  BOUNDS.y){ p.y =  BOUNDS.y; v.y = -Math.abs(v.y); }
        if (p.z < -BOUNDS.z){ p.z = -BOUNDS.z; v.z = Math.abs(v.z); }
        if (p.z >  BOUNDS.z){ p.z =  BOUNDS.z; v.z = -Math.abs(v.z); }

        const dir = this.vel.clone().normalize();
        if (dir.lengthSq() > 0.0001){
          const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dir);
          this.group.quaternion.slerp(targetQuat, 0.08);
        }

        const wag = Math.sin(t*6.0 + this.phase) * 0.35;
        this.group.userData.tailPivot.rotation.y = this.paused ? 0 : wag;
        this.group.userData.fins.forEach((fin,i)=>{
          fin.rotation.y = this.paused ? 0 : Math.sin(t*5.5 + this.phase + i)*0.12;
        });

        this.group.userData.bubble.lookAt(camera.position);

        for(const m of this.group.userData.mats){ m.uniforms.uTime.value = t; }

        if(this.fading){
          this.fade = Math.max(0, this.fade - dt*0.6);
          for(const m of this.group.userData.mats){ m.uniforms.uOpacity.value = this.fade; }
          this.group.userData.bubble.material.opacity = this.fade;
          this.group.userData.eyes.forEach(e=>{ e.material.opacity = this.fade; });

          if(this.fade<=0.0){
            world.remove(this.group);
            this.group.traverse(o=>{
              if(o.material){ o.material.dispose?.(); if(o.material.map) o.material.map.dispose?.(); }
              if(o.geometry){ o.geometry.dispose?.(); }
            });
            if(this.memBubble){
              const start = performance.now(), wait = 800, fadeDur = 1300;
              const tickMem = (now)=>{
                const tms = now - start;
                if(tms > wait){
                  const a = 1 - (tms - wait)/fadeDur;
                  this.memBubble.material.opacity = Math.max(0, a);
                  if(a<=0){ world.remove(this.memBubble); this.memBubble.material.map.dispose(); this.memBubble.material.dispose(); this.memBubble=null; return; }
                }
                requestAnimationFrame(tickMem);
              };
              requestAnimationFrame(tickMem);
            }
            this.group = null;
          }
        }
      }
      triggerFade(){ if(!this.fading && this.group) this.paused = true; }
    }

    // School with DISTINCT rainbow hues
    const FISH=[];
    const count = 24;
    for(let i=0;i<count;i++){
      const sheen = RAINBOW_SHEENS[i % RAINBOW_SHEENS.length];
      FISH.push(new Fish(sheen));
    }

    // Random thoughts
    setInterval(()=>{
      const alive = FISH.filter(f=>f.group && !f.fading);
      if(!alive.length) return;
      const f = choose(alive);
      if (f) updateBubbleText(f.group.userData.bubble, choose(PHRASES));
    }, 2000);

    /* ===== Sparkling water bubbles (lit) ===== */
    const bubbleCount=260;
    const bubbleGeo=new THREE.BufferGeometry();
    const positions=new Float32Array(bubbleCount*3);
    const speeds=new Float32Array(bubbleCount);
    const xDrifts=new Float32Array(bubbleCount);
    for(let i=0;i<bubbleCount;i++){
      positions[i*3+0]=rand(-6,6);
      positions[i*3+1]=rand(-3,3);
      positions[i*3+2]=rand(-4,4);
      speeds[i]=rand(0.12,0.45);
      xDrifts[i]=rand(-0.15,0.15);
    }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));

    const bubbleMat = new THREE.ShaderMaterial({
      transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
      uniforms:{
        uTime:{value:0},
        uLightDir:{value:key.position.clone()},
        uBase:{value:new THREE.Color(0xdff9ff)},
        uSpec:{value:new THREE.Color(0xffffff)}
      },
      vertexShader:/*glsl*/`
        precision highp float;
        uniform mat4 modelViewMatrix;
        uniform mat4 projectionMatrix;
        varying vec3 vWorldPos;
        void main(){
          vWorldPos = position;
          vec4 mv = modelViewMatrix * vec4(position,1.0);
          gl_PointSize = 3.5 * (300.0 / -mv.z);
          gl_Position = projectionMatrix * mv;
        }
      `,
      fragmentShader:/*glsl*/`
        precision highp float;
        uniform vec3 uLightDir;
        uniform vec3 uBase;
        uniform vec3 uSpec;
        uniform float uTime;
        varying vec3 vWorldPos;

        void main(){
          vec2 uv = gl_PointCoord * 2.0 - 1.0;
          float r2 = dot(uv,uv);
          if(r2 > 1.0) discard;
          float z = sqrt(1.0 - r2);
          vec3 N = normalize(vec3(uv.x, uv.y, z));
          vec3 L = normalize(uLightDir - vWorldPos);
          vec3 V = vec3(0.0,0.0,1.0);
          vec3 H = normalize(L + V);

          float diff = max(dot(N,L), 0.0);
          float spec = pow(max(dot(N,H), 0.0), 64.0);

          float tw = 0.5 + 0.5*sin(dot(vWorldPos, vec3(0.7,1.1,1.3))*2.0 + uTime*3.0);

          vec3 col = uBase * (0.15 + 0.85*diff) * (0.6 + 0.4*tw) + uSpec * spec;
          float alpha = smoothstep(1.0, 0.0, r2) * (0.65 + 0.35*tw);

          gl_FragColor = vec4(col, alpha);
          if(gl_FragColor.a < 0.02) discard;
        }
      `
    });

    const bubbles=new THREE.Points(bubbleGeo,bubbleMat); world.add(bubbles);
    function updateBubbles(dt){
      const arr=bubbleGeo.attributes.position.array;
      for(let i=0;i<bubbleCount;i++){
        let x=arr[i*3+0], y=arr[i*3+1], z=arr[i*3+2];
        y += speeds[i]*dt; x += xDrifts[i]*dt*0.4;
        if(y>3.2){ y=-3.2; x=rand(-6,6); z=rand(-4,4);
          speeds[i]=rand(0.12,0.45); xDrifts[i]=rand(-0.15,0.15);
        }
        arr[i*3+0]=x; arr[i*3+1]=y; arr[i*3+2]=z;
      }
      bubbleGeo.attributes.position.needsUpdate=true;
    }

    /* ===== Shark (visible & unfogged) ===== */
    const SHARK_SRC='shark.png';
    class Shark {
      constructor(){
        this.mesh=null; this.dir=1; this.speed=0.55;
        this.y=rand(0.4,1.2); this.z=-4.2; this.phase=Math.random()*Math.PI*2;
        this.flipBound=12.5;
        new THREE.TextureLoader().load(SHARK_SRC, tex=>{
          tex.colorSpace=THREE.SRGBColorSpace; tex.premultiplyAlpha=true;
          tex.generateMipmaps=false; tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;
          const aspect = tex.image.width / tex.image.height;
          const W = 11.0; const H = W / aspect;
          const mat = new THREE.MeshBasicMaterial({
            map:tex, transparent:true, opacity:0.82, depthWrite:false, fog:false,
            side:THREE.DoubleSide, alphaTest:0.02
          });
          this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(W,H), mat);
          this.mesh.position.set(-this.flipBound - 0.2, this.y, this.z);
          this.mesh.rotation.y = 0;
          world.add(this.mesh);
        }, undefined, ()=>{ console.warn('Could not load shark.png'); });
      }
      update(dt,t){
        if(!this.mesh) return;
        this.mesh.position.x += this.dir * this.speed * dt;
        this.mesh.position.y  = this.y + Math.sin(t*0.25 + this.phase) * 0.12;
        if(this.dir>0 && this.mesh.position.x >  this.flipBound){ this.dir=-1; this.mesh.rotation.y=Math.PI; }
        else if(this.dir<0 && this.mesh.position.x < -this.flipBound){ this.dir= 1; this.mesh.rotation.y=0; }
      }
    }
    const SHARK = new Shark();

    /* ===== Curved pan (outward) ===== */
    let mouseX = 0; // -1..1
    const panRange = 1.25;
    const yawRange = THREE.MathUtils.degToRad(7);
    addEventListener('pointermove', (e)=>{
      const nx = (e.clientX / innerWidth) * 2 - 1;
      mouseX = THREE.MathUtils.clamp(nx, -1, 1);
    });

    /* ===== Click-to-pause-then-fade ===== */
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    addEventListener('pointerdown', (e)=>{
      mouse.x =  (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      const meshes = [];
      world.traverse(o=>{ if(o.userData && o.userData.isFish){ o.traverse(c=>{ if(c.isMesh) meshes.push(c); }); }});
      const hit = ray.intersectObjects(meshes, true)[0];
      if(hit){
        let root = hit.object;
        while(root.parent && !root.userData.isFish) root = root.parent;
        const fish = FISH.find(f=> f.group === root);
        fish?.triggerFade();
      }
    });

    /* ===== Build school (distinct rainbow hues) ===== */
    const FISH=[];
    const count = 24;
    for(let i=0;i<count;i++){
      const sheen = RAINBOW_SHEENS[i % RAINBOW_SHEENS.length];
      FISH.push(new Fish(sheen));
    }

    /* ===== Random thoughts ===== */
    setInterval(()=>{
      const alive = FISH.filter(f=>f.group && !f.fading);
      if(!alive.length) return;
      const f = choose(alive);
      if (f) updateBubbleText(f.group.userData.bubble, choose(PHRASES));
    }, 2000);

    /* ===== Resize ===== */
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ===== Animate ===== */
    let last = performance.now();
    function tick(now){
      const dt = Math.min((now - last)/1000, 0.05); last = now;
      const t = now * 0.001;

      updateBackground(now);

      for(const r of RAYS){
        r.material.uniforms.uTime.value = t;
        r.position.x += Math.sin(t * r.userData.speed + r.id)*0.0008;
        r.position.z += Math.cos(t * r.userData.speed + r.id)*0.0006;
      }

      const targetX = Math.sin(mouseX * Math.PI/2) * panRange;
      world.position.x = THREE.MathUtils.lerp(world.position.x, targetX, 0.1);
      const targetYaw = mouseX * yawRange;
      world.rotation.y = THREE.MathUtils.lerp(world.rotation.y, targetYaw, 0.1);

      for(const f of FISH) f.update(dt, t);
      SHARK.update(dt,t);
      updateBubbles(dt);
      bubbleMat.uniforms.uTime.value = t;

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
