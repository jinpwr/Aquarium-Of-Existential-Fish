<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    html,body{
      height:100%;margin:0;overflow:hidden;
      background:linear-gradient(to bottom,#7fcde4 0%,#3b63c0 45%,#15053a 100%);
      animation:hueDrift 160s linear infinite alternate;
    }
    @keyframes hueDrift{
      0%{filter:hue-rotate(0deg);}
      50%{filter:hue-rotate(60deg);}
      100%{filter:hue-rotate(120deg);}
    }
    canvas{display:block}
    #overlay{
      position:fixed;inset:0;pointer-events:none;z-index:3;
      display:flex;align-items:flex-end;justify-content:flex-end;
      padding:12px 14px;
      font-family:ui-monospace,Menlo,Consolas,monospace;
      color:#b3f4ff;text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{font-weight:700;letter-spacing:.5px;font-size:12px;color:#9effc7}
  </style>
</head>
<body>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
    const scene=new THREE.Scene();
    scene.fog=new THREE.FogExp2(0x0e0830,0.06);
    const camera=new THREE.PerspectiveCamera(65,innerWidth/innerHeight,0.1,200);
    camera.position.set(0,2.2,7);
    const renderer=new THREE.WebGLRenderer({antialias:true,alpha:true});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth,innerHeight);
    renderer.outputColorSpace=THREE.SRGBColorSpace;
    renderer.toneMapping=THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure=1.6;
    document.body.appendChild(renderer.domElement);

    const hemi=new THREE.HemisphereLight(0xbfeaff,0x0f1033,0.7);
    const key=new THREE.PointLight(0x7cd9ff,26,120,1.8);key.position.set(5,4,6);
    const fill=new THREE.PointLight(0x6ff0d4,10,120,1.8);fill.position.set(-5,1.2,5);
    const rim=new THREE.PointLight(0x6b6bff,16,160,2.2);rim.position.set(0,3.6,-9);
    scene.add(hemi,key,fill,rim);

    const rand=(a,b)=>a+Math.random()*(b-a);

    const raycaster=new THREE.Raycaster();
    const mouseNDC=new THREE.Vector2();
    const plane=new THREE.Plane(new THREE.Vector3(0,0,1),0);
    const mouseWorld=new THREE.Vector3(999,999,0);
    let mouseX=0;const panRange=1.4;
    addEventListener('mousemove',e=>{
      mouseX=(e.clientX/innerWidth)*2-1;
      mouseNDC.x=mouseX;mouseNDC.y=-(e.clientY/innerHeight)*2+1;
      raycaster.setFromCamera(mouseNDC,camera);
      raycaster.ray.intersectPlane(plane,mouseWorld);
    });

    function makeBubbleSprite(text){
      const w=256,h=128;
      const c=document.createElement('canvas');c.width=w;c.height=h;
      const x=c.getContext('2d');
      x.fillStyle='rgba(0,0,0,0.35)';
      x.strokeStyle='rgba(255,255,255,0.85)';x.lineWidth=3;
      x.beginPath();x.moveTo(14,8);x.arcTo(w-8,8,w-8,h-8,14);
      x.arcTo(w-8,h-8,8,h-8,14);x.arcTo(8,h-8,8,8,14);x.arcTo(8,8,w-8,8,14);
      x.closePath();x.fill();x.stroke();
      x.font='600 22px ui-monospace,monospace';
      x.fillStyle='rgba(235,255,250,0.98)';
      x.textAlign='center';x.textBaseline='middle';
      x.fillText(text,w/2,h/2);
      const tex=new THREE.CanvasTexture(c);
      const mat=new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false});
      const s=new THREE.Sprite(mat);s.scale.set(2.2,1.1,1);
      s.userData={ctx:x,texture:tex};
      return s;
    }

    const BASES=[];
    for(let i=0;i<18;i++){
      const c=new THREE.Color().setHSL(i/18,0.85,0.55);
      BASES.push(`#${c.getHexString()}`);
    }

    function fishTexture(seed){
      const w=512,h=256,c=document.createElement('canvas');c.width=w;c.height=h;
      const g=c.getContext('2d');
      const base=new THREE.Color(seed);
      const belly=base.clone().lerp(new THREE.Color('#fff'),0.55);
      const back=base.clone().lerp(new THREE.Color('#000'),0.35);
      const grad=g.createLinearGradient(0,0,0,h);
      grad.addColorStop(0,`#${belly.getHexString()}`);
      grad.addColorStop(0.5,`#${base.getHexString()}`);
      grad.addColorStop(1,`#${back.getHexString()}`);
      g.fillStyle=grad;g.fillRect(0,0,w,h);
      g.globalAlpha=0.4;
      for(let x=0;x<w;x+=14){g.fillStyle=`rgba(255,255,255,${0.4*Math.random()})`;g.fillRect(x,0,6,h);}
      g.globalAlpha=1;
      for(let i=0;i<1500;i++){
        g.fillStyle=`rgba(255,255,255,${Math.random()*0.25})`;
        g.fillRect(Math.random()*w,Math.random()*h,1.5,1.5);
      }
      const tex=new THREE.CanvasTexture(c);
      tex.anisotropy=renderer.capabilities.getMaxAnisotropy();
      return tex;
    }

    const makeMat=(seed)=>new THREE.MeshStandardMaterial({
      map:fishTexture(seed),
      color:0xffffff,roughness:0.3,metalness:0.3,
      emissive:new THREE.Color(0x1a1a1a),
      emissiveIntensity:0.3,transparent:true
    });

    // --- Stylized Fish Model ---
    function createFishModel(color){
      const group=new THREE.Group();
      const body=new THREE.Mesh(new THREE.SphereGeometry(0.35,16,8),makeMat(color));
      body.scale.set(1.9,1,0.8);
      group.add(body);

      const tailShape=new THREE.ConeGeometry(0.25,0.5,3);
      const tail=new THREE.Mesh(tailShape,makeMat(color));
      tail.rotation.z=Math.PI;
      tail.position.x=-0.9;
      group.add(tail);

      const finGeo=new THREE.PlaneGeometry(0.3,0.2);
      const finMat=new THREE.MeshStandardMaterial({color:0xffffff,transparent:true,opacity:0.6,side:THREE.DoubleSide});
      const topFin=new THREE.Mesh(finGeo,finMat);
      topFin.position.set(0,-0.1,0.35);
      topFin.rotation.y=Math.PI/2;
      group.add(topFin);

      const bottomFin=topFin.clone();
      bottomFin.position.set(0,-0.1,-0.35);
      group.add(bottomFin);

      // Eyes
      const eyeMat=new THREE.MeshBasicMaterial({color:0x000000});
      const eyeGeo=new THREE.SphereGeometry(0.04,8,8);
      const eyeL=new THREE.Mesh(eyeGeo,eyeMat);
      eyeL.position.set(0.5,0.1,0.25);
      const eyeR=eyeL.clone();
      eyeR.position.z*=-1;
      group.add(eyeL,eyeR);

      return group;
    }

    const BOUNDS={x:5.8,y:2.9,z:3.8};
    class Fish{
      constructor(color){
        this.group=createFishModel(color);
        this.bubble=makeBubbleSprite("be kind to the void");
        this.bubble.position.set(0,0.9,0);
        this.group.add(this.bubble);
        this.group.position.set(rand(-4,4),rand(-1.2,2.2),rand(-2.5,2.5));
        this.vel=new THREE.Vector3(rand(-0.02,0.02),rand(-0.01,0.01),rand(-0.015,0.015));
        this.dead=false;
        scene.add(this.group);
      }
      fade(){
        if(this.dead)return;this.dead=true;
        this.group.remove(this.bubble);scene.remove(this.bubble);
        const farewell=makeBubbleSprite("i will remember this.");
        farewell.position.copy(this.group.position).add(new THREE.Vector3(0,0.9,0));
        scene.add(farewell);
        const start=performance.now();
        const fadeOut=()=>{
          const t=(performance.now()-start)/1500;
          this.group.traverse(o=>{if(o.material)o.material.opacity=1-t;});
          if(t<1)requestAnimationFrame(fadeOut);else scene.remove(this.group);
        };
        fadeOut();
        const msgStart=performance.now();
        const msgAnim=()=>{
          const t=(performance.now()-msgStart)/4000;
          farewell.position.y+=0.002;
          farewell.material.opacity=1-t;
          if(t<1)requestAnimationFrame(msgAnim);else scene.remove(farewell);
        };msgAnim();
      }
      update(dt){
        if(this.dead)return;
        const p=this.group.position;
        p.addScaledVector(this.vel,dt*60);
        if(p.x<-BOUNDS.x||p.x>BOUNDS.x)this.vel.x*=-1;
        if(p.y<-BOUNDS.y||p.y>BOUNDS.y)this.vel.y*=-1;
        if(p.z<-BOUNDS.z||p.z>BOUNDS.z)this.vel.z*=-1;
        const dir=new THREE.Vector3().copy(this.vel).normalize();
        const angle=Math.atan2(-dir.z,dir.x);
        this.group.rotation.y=angle;
        this.bubble.lookAt(camera.position);
      }
    }

    const FISH=[];
    for(let i=0;i<18;i++)FISH.push(new Fish(BASES[i]));

    addEventListener('click',e=>{
      mouseNDC.x=(e.clientX/innerWidth)*2-1;
      mouseNDC.y=-(e.clientY/innerHeight)*2+1;
      raycaster.setFromCamera(mouseNDC,camera);
      const hits=raycaster.intersectObjects(FISH.map(f=>f.group.children[0]));
      if(hits.length){
        const f=FISH.find(ff=>ff.group.children.includes(hits[0].object));
        if(f)f.fade();
      }
    });

    // floating bubbles
    const bubbleGeo=new THREE.BufferGeometry();
    const bubbleCount=220,pos=new Float32Array(bubbleCount*3),speed=new Float32Array(bubbleCount);
    for(let i=0;i<bubbleCount;i++){pos[i*3]=rand(-6,6);pos[i*3+1]=rand(-3,3);pos[i*3+2]=rand(-4,4);speed[i]=rand(0.12,0.45);}
    bubbleGeo.setAttribute('position',new THREE.BufferAttribute(pos,3));
    const bubbleMat=new THREE.PointsMaterial({color:0xdff9ff,size:0.06,transparent:true,opacity:0.7,depthWrite:false,blending:THREE.AdditiveBlending});
    const bubbles=new THREE.Points(bubbleGeo,bubbleMat);scene.add(bubbles);
    function updateBubbles(dt){const a=bubbleGeo.attributes.position.array;for(let i=0;i<bubbleCount;i++){a[i*3+1]+=speed[i]*dt;if(a[i*3+1]>3.2)a[i*3+1]=-3.2;}bubbleGeo.attributes.position.needsUpdate=true;}

    // Shark plane
    const SHARK_SRC='shark.png';
    class Shark{
      constructor(){
        this.dir=1;this.speed=0.55;
        this.y=rand(0.2,1.2);this.z=-7.8;
        this.phase=Math.random()*Math.PI*2;this.flipBound=16.5;
        new THREE.TextureLoader().load(SHARK_SRC,t=>{
          t.colorSpace=THREE.SRGBColorSpace;t.premultiplyAlpha=true;
          const aspect=t.image.width/t.image.height,W=19,H=W/aspect;
          const m=new THREE.MeshBasicMaterial({map:t,transparent:true,opacity:0.75,depthWrite:false,side:THREE.DoubleSide,alphaTest:0.03});
          this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(W,H),m);
          this.mesh.position.set(-this.flipBound-0.2,this.y,this.z);
          scene.add(this.mesh);
        });
      }
      update(dt,t){
        if(!this.mesh)return;
        this.mesh.position.x+=this.dir*this.speed*dt;
        this.mesh.position.y=this.y+Math.sin(t*0.25+this.phase)*0.12;
        if(this.dir>0&&this.mesh.position.x>this.flipBound){this.dir=-1;this.mesh.rotation.y=Math.PI;}
        else if(this.dir<0&&this.mesh.position.x<-this.flipBound){this.dir=1;this.mesh.rotation.y=0;}
      }
    }
    const SHARK=new Shark();

    addEventListener('resize',()=>{camera.aspect=innerWidth/innerHeight;camera.updateProjectionMatrix();renderer.setSize(innerWidth,innerHeight);});

    let last=performance.now();
    function tick(now){
      const dt=Math.min((now-last)/1000,0.05);last=now;
      const targetX=mouseX*panRange;camera.position.x+=(targetX-camera.position.x)*0.05;camera.lookAt(0,0,0);
      for(const f of FISH)f.update(dt);
      updateBubbles(dt);
      SHARK.update(dt,now*0.001);
      renderer.render(scene,camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
