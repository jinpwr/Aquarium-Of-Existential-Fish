<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      /* JS will animate this, hue-locked to blue→violet and a bit lighter than last dark pass */
      background: linear-gradient(to bottom,
        hsl(230 55% 30%) 0%,
        hsl(236 55% 20%) 40%,
        hsl(242 55% 12%) 100%
      );
    }
    canvas { display:block }

    /* film grain */
    #dither{
      position:fixed; inset:0; pointer-events:none; opacity:.12; z-index:2;
      background-image:url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="black" opacity="0"/><rect x="0" y="0" width="2" height="2" fill="white" opacity="0.07"/><rect x="2" y="2" width="2" height="2" fill="white" opacity="0.07"/></svg>');
      image-rendering:pixelated; background-size:4px; background-repeat:repeat; mix-blend-mode:overlay;
    }

    /* overlays */
    #overlay{
      position:fixed; inset:0; pointer-events:none; z-index:4;
      display:flex; align-items:flex-end; justify-content:flex-end;
      padding: 12px 14px;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      color:#b3f4ff; text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{ font-weight:700; letter-spacing:.5px; font-size:12px; color:#9effc7; }

    #instructions{
      position:fixed; left:12px; bottom:10px; z-index:4; pointer-events:none;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      font-size:12px; line-height:1.5;
      color:#9effc7; /* same color as title */
      text-shadow:0 1px 2px rgba(0,0,0,.3);
      white-space:pre-line;
    }
  </style>
</head>
<body>
  <div id="dither"></div>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>
  <div id="instructions">move mouse horizontally to look around (curved pan)
click a fish to pause it, then it will fade and leave a note</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /* ===== Scene / World (for parallax & yaw) ===== */
    const scene = new THREE.Scene();
    const world = new THREE.Group();   // all content goes under this
    scene.add(world);
    scene.fog = new THREE.FogExp2(0x0e0a2a, 0.05);

    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);
    camera.lookAt(0,0,0);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true, premultipliedAlpha: false });
    renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.9;
    document.body.appendChild(renderer.domElement);

    /* ===== Lights (more dramatic) ===== */
    const hemi = new THREE.HemisphereLight(0xaad9ff, 0x0b0018, 0.35);
    const key  = new THREE.DirectionalLight(0xb0d6ff, 1.4); key.position.set(4, 6, 2);
    const fill = new THREE.DirectionalLight(0x66ffd2, 0.35);  fill.position.set(-5, 2, -3);
    const rim  = new THREE.DirectionalLight(0x8b86ff, 0.9);   rim.position.set(0, 3.5, -6);
    scene.add(hemi, key, fill, rim);

    /* ===== Helpers ===== */
    const rand = (a,b)=> a + Math.random()*(b-a);
    const choose = arr => arr[(Math.random()*arr.length)|0];

    /* ===== Background hue (locked to blue→violet) ===== */
    const BG = {
      HUE_MIN: 225,   // blue
      HUE_MAX: 270,   // violet (no green)
      SAT: 55,        // %
      L1: 30, L2: 20, L3: 12,
      speed: 0.06
    };
    function updateBackground(nowMs){
      const t = nowMs * 0.001;
      const u = (Math.sin(t * BG.speed) + 1) / 2; // 0..1
      const hue = BG.HUE_MIN + u * (BG.HUE_MAX - BG.HUE_MIN);
      const h1 = hue, h2 = (hue + 6) % 360, h3 = (hue + 12) % 360;
      document.body.style.background =
        `linear-gradient(to bottom,
          hsl(${h1} ${BG.SAT}% ${BG.L1}%) 0%,
          hsl(${h2} ${BG.SAT}% ${BG.L2}%) 40%,
          hsl(${h3} ${BG.SAT}% ${BG.L3}%) 100%
        )`;
    }

    /* ===== Soft God-Rays ===== */
    function makeGodRay(){
      const geo = new THREE.ConeGeometry(6.5, 16, 64, 1, true);
      geo.rotateX(-Math.PI/2);
      const mat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{ uTime:{value:0}, uTint:{value:new THREE.Color(0xbfe8ff)}, uOpacity:{value:0.18} },
        vertexShader:/*glsl*/`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader:/*glsl*/`
          varying vec2 vUv; uniform vec3 uTint; uniform float uTime,uOpacity;
          void main(){
            float r = 1.0 - vUv.y;
            float radial = smoothstep(0.0,0.6,r)*(1.0 - smoothstep(0.6,1.0,r));
            float band = 0.5 + 0.5*sin(vUv.x*22.0 + uTime*0.4);
            float alpha = radial * (0.35 + 0.65*band);
            alpha *= (1.0 - vUv.x*0.6);
            alpha *= uOpacity;
            if(alpha < 0.01) discard;
            gl_FragColor = vec4(uTint, alpha);
          }`
      });
      const m = new THREE.Mesh(geo, mat);
      m.position.set(rand(-2,2), 5.8, rand(-1.5,1.5));
      m.rotation.z = rand(-0.15,0.15);
      m.userData.speed = rand(0.3, 0.7);
      return m;
    }
    const RAYS = [];
    for(let i=0;i<4;i++){ const r=makeGodRay(); RAYS.push(r); world.add(r); }

    /* ===== Bubbles & Speech bubbles ===== */
    function makeBubbleSprite(text){
      const w=256,h=128;
      const cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h;
      const ctx=cvs.getContext('2d');
      ctx.fillStyle='rgba(0,0,0,0.24)';
      ctx.strokeStyle='rgba(220,255,250,0.75)'; ctx.lineWidth=2;
      roundRect(ctx,8,8,w-16,h-16,14,true,true);
      ctx.font='600 22px ui-monospace, monospace';
      ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
      wrapText(ctx,text,w/2,h/2,w-36,28);
      const tex=new THREE.CanvasTexture(cvs);
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false, opacity:1 });
      const spr=new THREE.Sprite(mat); spr.scale.set(2.2,1.1,1);
      spr.userData={canvas:cvs,ctx,texture:tex, material:mat};
      return spr;
    }
    function updateBubbleText(sprite, text){
      const { canvas:cvs, ctx, texture:tex } = sprite.userData;
      const w=cvs.width,h=cvs.height;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle='rgba(0,0,0,0.24)';
      ctx.strokeStyle='rgba(220,255,250,0.75)'; ctx.lineWidth=2;
      roundRect(ctx,8,8,w-16,h-16,14,true,true);
      ctx.font='600 22px ui-monospace, monospace';
      ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
      wrapText(ctx,text,w/2,h/2,w-36,28);
      tex.needsUpdate=true;
    }
    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      ctx.beginPath();
      ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r);
      ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r);
      ctx.arcTo(x,y,x+w,y,r);
      ctx.closePath();
      if(fill)ctx.fill();
      if(stroke)ctx.stroke();
    }
    function wrapText(ctx,text,x,y,maxWidth,lineHeight){
      const words=text.split(' '); const lines=[]; let line='';
      for(const w of words){
        const test=line?line+' '+w:w;
        if(ctx.measureText(test).width>maxWidth){ lines.push(line); line=w; } else line=test;
      }
      if(line)lines.push(line);
      const total=lines.length*lineHeight; let curY=y-total/2+lineHeight/2;
      for(const l of lines){ ctx.fillText(l,x,curY); curY+=lineHeight; }
    }

    /* ===== NEW Fish material: fine sand-like grain with dramatic light ===== */
    // bright sheen choices (tinted where light hits)
    const SHEEN_COLORS = [
      new THREE.Color(0x7FFFD4), // aquamarine
      new THREE.Color(0x7FB3FF), // soft blue
      new THREE.Color(0x9A7BFF), // purple
      new THREE.Color(0x66FFC2), // mint
      new THREE.Color(0x89A8FF), // periwinkle
      new THREE.Color(0x52E8FF)  // azure
    ];

    // Shader: near-black sand grain in shadow; bright tinted sheen in light, plus specular & rim
    const FishSandMaterial = (sheenColor)=>{
      return new THREE.ShaderMaterial({
        transparent:true, depthWrite:true, fog:true,
        uniforms:{
          uLightDir: { value: new THREE.Vector3().copy(key.position).normalize() },
          uDark:     { value: new THREE.Color(0x04040a) },  // nearly black
          uSheen:    { value: sheenColor.clone() },         // saturated
          uOpacity:  { value: 1.0 },
          uTime:     { value: 0 },
          uGrain:    { value: 42.0 },  // grain density
          uSpecPow:  { value: 64.0 },  // specular power
          uRimPow:   { value: 2.2 },   // rim effect power
          uRimStr:   { value: 0.35 }   // rim strength
        },
        vertexShader:/*glsl*/`
          varying vec3 vN;
          varying vec3 vW;
          varying vec2 vUv;
          void main(){
            vN = normalize(normalMatrix * normal);
            vec4 wp = modelMatrix * vec4(position,1.0);
            vW = wp.xyz;
            vUv = uv;
            gl_Position = projectionMatrix * viewMatrix * wp;
          }
        `,
        fragmentShader:/*glsl*/`
          varying vec3 vN;
          varying vec3 vW;
          varying vec2 vUv;
          uniform vec3 uLightDir, uDark, uSheen;
          uniform float uOpacity, uTime, uGrain, uSpecPow, uRimPow, uRimStr;

          // tiny hash noise (fine sand)
          float hash(vec3 p){
            p = fract(p * 0.3183099 + vec3(0.1,0.2,0.3));
            p += dot(p, p.yzx + 19.19);
            return fract((p.x+p.y)*p.z);
          }
          float grain(vec3 p){
            // stack a couple frequencies for tight sand look
            float g = hash(p*uGrain);
            g = mix(g, hash(p*uGrain*1.7), 0.5);
            return g;
          }

          void main(){
            vec3 N = normalize(vN);
            vec3 L = normalize(uLightDir);
            vec3 V = normalize(cameraPosition - vW);
            vec3 H = normalize(L + V);

            // Stronger diffuse rolloff for drama
            float ndotl = max(dot(N,L), 0.0);
            float diffuse = pow(ndotl, 1.2);  // steeper falloff

            // Specular (Blinn-Phong)
            float spec = pow(max(dot(N,H), 0.0), uSpecPow);

            // Rim lighting (subtle violet-blue push)
            float rim = pow(1.0 - max(dot(N,V), 0.0), uRimPow) * uRimStr;

            // Fine sand grain modulates both dark base and sheen
            float g = grain(vW + vec3(0.0, uTime*0.15, 0.0));
            float grainDark = mix(0.65, 1.0, g);        // darker modulation
            float grainLight = mix(0.85, 1.15, g);      // highlight sparkle

            vec3 colDark = uDark * grainDark;
            vec3 colSheen = uSheen * (0.35 + 0.65*diffuse) * grainLight;

            // combine: deep shadow + tinted highlight + rim + spec
            vec3 color = mix(colDark, colSheen, diffuse);
            color += spec * (uSheen * 0.9 + vec3(0.08,0.1,0.12)); // specular tint and white boost
            color += rim * vec3(0.25, 0.28, 0.45);

            gl_FragColor = vec4(color, uOpacity);
            if(gl_FragColor.a < 0.02) discard;
          }
        `
      });
    };

    /* ===== Fish build (tail pivot fixed) ===== */
    const PHRASES = [
      'i am not real','today i forgot myself','be kind to the void','do fish dream?',
      '404: meaning not found','blink slowly','pretend to be water','becoming … becoming','a small thought floats'
    ];
    const BOUNDS = { x: 5.8, y: 2.9, z: 3.8 };

    function makeFishMesh(){
      const g=new THREE.Group(); g.userData.isFish = true;

      // Body
      const radius = rand(0.25,0.38);
      const sx = rand(1.7, 2.2);
      const bodyGeo=new THREE.IcosahedronGeometry(radius, 0);
      bodyGeo.computeBoundingBox();
      bodyGeo.scale(sx, 1, 1);

      const sheen = choose(SHEEN_COLORS);
      const bodyMat = FishSandMaterial(sheen);
      const body=new THREE.Mesh(bodyGeo, bodyMat); g.add(body);

      // Tail with clean pivot
      const tailLen = 0.38;
      const tailGeo=new THREE.ConeGeometry(0.20, tailLen, 5);
      tailGeo.translate(0, -tailLen*0.5, 0);
      const tailMat = FishSandMaterial(sheen);
      const tailMesh=new THREE.Mesh(tailGeo, tailMat);

      const tailPivot = new THREE.Group();
      tailPivot.add(tailMesh);
      tailPivot.rotation.z = Math.PI/2;
      const bodyMinX = -radius * sx;
      tailPivot.position.set(bodyMinX - 0.06, 0, 0);
      g.add(tailPivot);

      // Fins
      const finGeo=new THREE.ConeGeometry(0.08,0.18,5);
      finGeo.translate(0, -0.09, 0);
      const finMat = FishSandMaterial(sheen);
      const finL=new THREE.Mesh(finGeo,finMat);
      const finR=new THREE.Mesh(finGeo,finMat.clone());
      finL.position.set(0.08,-0.05, 0.16); finL.rotation.z=-Math.PI/2.6;
      finR.position.set(0.08,-0.05,-0.16); finR.rotation.z=-Math.PI/2.6; finR.rotation.y=Math.PI;
      g.add(finL,finR);

      // Eyes
      const eyeGeo=new THREE.SphereGeometry(0.038,12,12);
      const eyeMat=new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.25, metalness:0.1, transparent:true, opacity:1 });
      const eyeL=new THREE.Mesh(eyeGeo,eyeMat), eyeR=new THREE.Mesh(eyeGeo,eyeMat);
      eyeL.position.set(0.42,0.06,0.12); eyeR.position.set(0.42,0.06,-0.12); g.add(eyeL,eyeR);

      // Bubble
      const bubble=makeBubbleSprite(choose(PHRASES)); bubble.position.set(0,0.9,0); g.add(bubble);

      // Cache
      g.userData = {
        ...g.userData,
        body, tailPivot, tailMesh, fins:[finL,finR], eyes:[eyeL,eyeR], bubble,
        mats:[bodyMat, tailMat, finMat, finR.material],
        sheen
      };

      return g;
    }

    class Fish{
      constructor(){
        this.group=makeFishMesh(); world.add(this.group);
        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel=new THREE.Vector3(rand(-0.02,0.02), rand(-0.01,0.01), rand(-0.015,0.015));
        this.turn=new THREE.Vector3(rand(-0.001,0.001), rand(-0.001,0.001), rand(-0.001,0.001));
        this.speed=rand(0.003,0.018);
        this.phase = Math.random()*Math.PI*2;

        this.paused = false;
        this.fading = false;
        this.fade = 1.0;
        this.pauseTimer = 0; // time spent paused before fade
      }
      update(dt, t){
        if(!this.group) return;

        // pause behavior before fade
        if(this.paused && !this.fading){
          this.pauseTimer += dt;
          if(this.pauseTimer >= 0.35){ this.fading = true; } // short pause, then fade
        }

        // wander unless paused
        if(!this.paused){
          this.vel.x += this.turn.x * dt; this.vel.y += this.turn.y * dt; this.vel.z += this.turn.z * dt;
          this.vel.clampLength(0, this.speed);
          this.group.position.addScaledVector(this.vel, dt * 60);
        }

        // clamp & bounce
        const p = this.group.position, v = this.vel;
        if (p.x < -BOUNDS.x){ p.x = -BOUNDS.x; v.x = Math.abs(v.x); }
        if (p.x >  BOUNDS.x){ p.x =  BOUNDS.x; v.x = -Math.abs(v.x); }
        if (p.y < -BOUNDS.y){ p.y = -BOUNDS.y; v.y = Math.abs(v.y); }
        if (p.y >  BOUNDS.y){ p.y =  BOUNDS.y; v.y = -Math.abs(v.y); }
        if (p.z < -BOUNDS.z){ p.z = -BOUNDS.z; v.z = Math.abs(v.z); }
        if (p.z >  BOUNDS.z){ p.z =  BOUNDS.z; v.z = -Math.abs(v.z); }

        // face swim direction
        const dir = this.vel.clone().normalize();
        if (dir.lengthSq() > 0.0001){
          const targetQuat = new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dir);
          this.group.quaternion.slerp(targetQuat, 0.08);
        }

        // natural tail & fin wiggle (stop when paused)
        const wag = Math.sin(t*6.0 + this.phase) * 0.35;
        this.group.userData.tailPivot.rotation.y = this.paused ? 0 : wag;
        this.group.userData.fins.forEach((fin,i)=>{
          fin.rotation.y = this.paused ? 0 : Math.sin(t*5.5 + this.phase + i)*0.12;
        });

        // bubble faces camera
        this.group.userData.bubble.lookAt(camera.position);

        // material times (subtle animated grain)
        for(const m of this.group.userData.mats){ m.uniforms.uTime.value = t; }

        // fading (fish + eyes + its bubble together)
        if(this.fading){
          this.fade = Math.max(0, this.fade - dt*0.6);
          for(const m of this.group.userData.mats){ m.uniforms.uOpacity.value = this.fade; }
          this.group.userData.bubble.material.opacity = this.fade;
          this.group.userData.eyes.forEach(e=>{ e.material.opacity = this.fade; });
          if(this.fade<=0.0){
            // position for memory bubble BEFORE removing group
            const bubblePos = this.group.localToWorld(new THREE.Vector3(0,0.9,0));
            // remove & dispose
            world.remove(this.group);
            this.group.traverse(o=>{
              if(o.material){
                if(o.material.map) o.material.map.dispose?.();
                o.material.dispose?.();
              }
              if(o.geometry){ o.geometry.dispose?.(); }
            });
            // memory bubble placed exactly where the old bubble was, no shooting
            const mem = makeBubbleSprite('i will remember this.');
            mem.position.copy(bubblePos);
            world.add(mem);
            // gentle linger fade (no upward shoot)
            const start = performance.now();
            const wait = 2200;
            const fadeDur = 1300;
            const tickMem = (now)=>{
              const tms = now - start;
              if(tms > wait){
                const a = 1 - (tms - wait)/fadeDur;
                mem.material.opacity = Math.max(0, a);
                if(a<=0){ world.remove(mem); mem.material.map.dispose(); mem.material.dispose(); return; }
              }
              requestAnimationFrame(tickMem);
            };
            requestAnimationFrame(tickMem);
            this.group = null;
          }
        }
      }
      triggerFade(){
        if((this.fading || !this.group)) return;
        this.paused = true; // pause first, fade shortly after
      }
    }

    // School
    const FISH=[];
    for(let i=0;i<24;i++) FISH.push(new Fish());

    // Random thoughts
    setInterval(()=>{
      const alive = FISH.filter(f=>f.group && !f.fading);
      if(!alive.length) return;
      const f = choose(alive);
      if (f) updateBubbleText(f.group.userData.bubble, choose(PHRASES));
    }, 2000);

    /* ===== Floating water bubbles ===== */
    const bubbleCount=220;
    const bubbleGeo=new THREE.BufferGeometry();
    const positions=new Float32Array(bubbleCount*3);
    const speeds=new Float32Array(bubbleCount);
    const xDrifts=new Float32Array(bubbleCount);
    for(let i=0;i<bubbleCount;i++){
      positions[i*3+0]=rand(-6,6);
      positions[i*3+1]=rand(-3,3);
      positions[i*3+2]=rand(-4,4);
      speeds[i]=rand(0.12,0.45);
      xDrifts[i]=rand(-0.15,0.15);
    }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
    const bubbleMat=new THREE.PointsMaterial({
      color:0xdff9ff, size:0.06, sizeAttenuation:true, transparent:true, opacity:0.7,
      depthWrite:false, blending:THREE.AdditiveBlending
    });
    const bubbles=new THREE.Points(bubbleGeo,bubbleMat); world.add(bubbles);
    function updateBubbles(dt){
      const arr=bubbleGeo.attributes.position.array;
      for(let i=0;i<bubbleCount;i++){
        let x=arr[i*3+0], y=arr[i*3+1], z=arr[i*3+2];
        y += speeds[i]*dt; x += xDrifts[i]*dt*0.4;
        if(y>3.2){ y=-3.2; x=rand(-6,6); z=rand(-4,4);
          speeds[i]=rand(0.12,0.45); xDrifts[i]=rand(-0.15,0.15);
        }
        arr[i*3+0]=x; arr[i*3+1]=y; arr[i*3+2]=z;
      }
      bubbleGeo.attributes.position.needsUpdate=true;
    }

    /* ===== Shark (visible again) ===== */
    const SHARK_SRC='shark.png'; // ensure this file sits next to the HTML
    class Shark {
      constructor(){
        this.mesh=null; this.dir=1; this.speed=0.55;
        this.y=rand(0.4,1.2); this.z=-4.8; this.phase=Math.random()*Math.PI*2;
        this.flipBound=12.5;
        new THREE.TextureLoader().load(SHARK_SRC, tex=>{
          tex.colorSpace=THREE.SRGBColorSpace; tex.premultiplyAlpha=true;
          tex.generateMipmaps=false; tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;
          const aspect = tex.image.width / tex.image.height;
          const W = 11.0; const H = W / aspect;
          const mat = new THREE.MeshBasicMaterial({
            map:tex, transparent:true, opacity:0.72, depthWrite:false, fog:false, // fog off so it doesn’t vanish
            side:THREE.DoubleSide, alphaTest:0.02
          });
          this.mesh = new THREE.Mesh(new THREE.PlaneGeometry(W,H), mat);
          this.mesh.position.set(-this.flipBound - 0.2, this.y, this.z);
          this.mesh.rotation.y = 0;
          world.add(this.mesh);
        });
      }
      update(dt,t){
        if(!this.mesh) return;
        this.mesh.position.x += this.dir * this.speed * dt;
        this.mesh.position.y  = this.y + Math.sin(t*0.25 + this.phase) * 0.12;
        if(this.dir>0 && this.mesh.position.x >  this.flipBound){ this.dir=-1; this.mesh.rotation.y=Math.PI; }
        else if(this.dir<0 && this.mesh.position.x < -this.flipBound){ this.dir= 1; this.mesh.rotation.y=0; }
      }
    }
    const SHARK = new Shark();

    /* ===== Curved mouse pan (parallax + yaw) ===== */
    let mouseX = 0; // -1..1
    const panRange = 1.2;          // lateral shift
    const yawRange = THREE.MathUtils.degToRad(6); // slight yaw turn
    addEventListener('pointermove', (e)=>{
      const nx = (e.clientX / innerWidth) * 2 - 1;
      mouseX = THREE.MathUtils.clamp(nx, -1, 1);
    });

    /* ===== Click-to-pause-then-fade (raycaster) ===== */
    const ray = new THREE.Raycaster();
    const mouse = new THREE.Vector2();
    addEventListener('pointerdown', (e)=>{
      mouse.x =  (e.clientX / innerWidth) * 2 - 1;
      mouse.y = -(e.clientY / innerHeight) * 2 + 1;
      ray.setFromCamera(mouse, camera);
      // gather fish meshes
      const meshes = [];
      world.traverse(o=>{ if(o.userData && o.userData.isFish){ o.traverse(c=>{ if(c.isMesh) meshes.push(c); }); }});
      const hit = ray.intersectObjects(meshes, true)[0];
      if(hit){
        // climb to fish root
        let root = hit.object;
        while(root.parent && !root.userData.isFish) root = root.parent;
        const fish = FISH.find(f=> f.group === root);
        fish?.triggerFade();
      }
    });

    /* ===== Resize ===== */
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ===== Animate ===== */
    let last = performance.now();
    function tick(now){
      const dt = Math.min((now - last)/1000, 0.05); last = now;
      const t = now * 0.001;

      // bg hue animation
      updateBackground(now);

      // god-rays
      for(const r of RAYS){
        r.material.uniforms.uTime.value = t;
        r.position.x += Math.sin(t * r.userData.speed + r.id)*0.0008;
        r.position.z += Math.cos(t * r.userData.speed + r.id)*0.0006;
      }

      // curved pan: x parallax + slight yaw for “look-around”
      const targetX = -Math.sin(mouseX * Math.PI/2) * panRange;
      world.position.x = THREE.MathUtils.lerp(world.position.x, targetX, 0.08);
      const targetYaw = -mouseX * yawRange;
      world.rotation.y = THREE.MathUtils.lerp(world.rotation.y, targetYaw, 0.08);

      // update fish
      for(const f of FISH) f.update(dt, t);

      // shark
      SHARK.update(dt,t);

      // bubbles
      updateBubbles(dt);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
