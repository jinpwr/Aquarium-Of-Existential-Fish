function makeFishMesh(){
  const g = new THREE.Group();

  // keep your existing palette vibe
  const baseHex = choose(PALETTE);
  const bodyMat = makeMatFromHex(baseHex);

  // slightly lighter, translucent fin/tail material (subtle glow)
  const finMat = new THREE.MeshStandardMaterial({
    color: new THREE.Color(baseHex).lerp(new THREE.Color(0xffffff), 0.35),
    roughness: 0.5,
    metalness: 0.15,
    emissive: new THREE.Color(0x355cff),
    emissiveIntensity: 0.12,
    transparent: true,
    opacity: 0.58,
    side: THREE.DoubleSide,
    depthWrite: false,
    blending: THREE.AdditiveBlending
  });

  // --- Body: elongated smooth sphere (earlier style) ---
  const bodyGeo = new THREE.SphereGeometry(0.36, 24, 16);
  const body    = new THREE.Mesh(bodyGeo, bodyMat);
  body.scale.set(1.9, 1.0, 0.85);     // long, elegant shape
  g.add(body);

  // --- Tail: longer, fork-like cone (keeps old wiggle behavior) ---
  const tailGeo = new THREE.ConeGeometry(0.26, 0.55, 12);
  const tail    = new THREE.Mesh(tailGeo, finMat);
  tail.rotation.z = Math.PI;          // points backward
  tail.position.x = -0.95;            // attach at back of body
  g.add(tail);

  // --- Dorsal & ventral fins: elegant and long (cones so your update() wiggle still works) ---
  const longFinGeo = new THREE.ConeGeometry(0.10, 0.34, 12);
  const finTop = new THREE.Mesh(longFinGeo, finMat.clone());
  const finBot = new THREE.Mesh(longFinGeo, finMat.clone());

  // make them ribbon-like
  finTop.rotation.set(Math.PI * 0.5, 0, 0);   // lay it down
  finBot.rotation.set(-Math.PI * 0.5, 0, 0);
  finTop.position.set(0.12, 0.22, 0.0);
  finBot.position.set(0.06, -0.22, 0.0);
  g.add(finTop, finBot);

  // --- Pectoral fins: small and swept back (also cones for wiggle) ---
  const pecGeo = new THREE.ConeGeometry(0.08, 0.22, 10);
  const pecL = new THREE.Mesh(pecGeo, finMat.clone());
  const pecR = new THREE.Mesh(pecGeo, finMat.clone());
  pecL.position.set(0.25, -0.06, 0.28);
  pecR.position.set(0.25, -0.06, -0.28);
  pecL.rotation.set(0, Math.PI/2.6,  Math.PI/10);
  pecR.rotation.set(0, -Math.PI/2.6, -Math.PI/10);
  g.add(pecL, pecR);

  // --- Eyes (same placement as before) ---
  const eyeGeo = new THREE.SphereGeometry(0.04, 12, 12);
  const eyeMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.1, metalness: 0.2, transparent: true, opacity: 1 });
  const eyeL = new THREE.Mesh(eyeGeo, eyeMat);
  const eyeR = eyeL.clone();
  eyeL.position.set(0.48, 0.06, 0.14);
  eyeR.position.set(0.48, 0.06, -0.14);
  g.add(eyeL, eyeR);

  return g;
}
