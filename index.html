<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    html, body { height:100%; margin:0; overflow:hidden;
      /* BG (light → dark) */
      background: linear-gradient(to bottom,#004f9c 0%,#002144 48%,#000b17 100%);
    }
    canvas{display:block}
    #dither{position:fixed; inset:0; pointer-events:none; opacity:.14; z-index:2;
      background-image:url('data:image/svg;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="black" opacity="0"/><rect x="0" y="0" width="2" height="2" fill="white" opacity="0.08"/><rect x="2" y="2" width="2" height="2" fill="white" opacity="0.08"/></svg>');
      image-rendering:pixelated; background-size:4px; background-repeat:repeat; mix-blend-mode:overlay;}
    #overlay{position:fixed; inset:0; pointer-events:none; z-index:4; display:flex; align-items:flex-end; justify-content:flex-end; padding:12px 14px; font-family:ui-monospace,Menlo,Consolas,monospace; color:#b3f4ff; text-shadow:0 1px 2px rgba(0,0,0,.25)}
    #overlay .title{font-weight:700; letter-spacing:.5px; font-size:12px; color:#9effc7}
    #instructions{position:fixed; left:12px; bottom:10px; z-index:4; pointer-events:none; font-family:ui-monospace,Menlo,Consolas,monospace; font-size:12px; line-height:1.5; color:#9effc7; text-shadow:0 1px 2px rgba(0,0,0,.3)}
  </style>
</head>
<body>
  <div id="dither"></div>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>
  <div id="instructions">move mouse horizontally to look around / try clicking on a fish</div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /* ===== scene / renderer ===== */
    const scene = new THREE.Scene();
    const world = new THREE.Group(); scene.add(world);
    scene.fog = new THREE.FogExp2(0x0c1526, 0.055);

    // camera sits on a rig we rotate for curved parallax
    const rig = new THREE.Group(); scene.add(rig);
    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7); // radius from origin
    rig.add(camera);

    const renderer = new THREE.WebGLRenderer({antialias:true, alpha:true, premultipliedAlpha:false});
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth,innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 0.9;
    document.body.appendChild(renderer.domElement);

    /* ===== lights ===== */
    const hemi = new THREE.HemisphereLight(0xaad9ff, 0x0b0018, 0.35);
    const key  = new THREE.DirectionalLight(0xb0d6ff, 1.35); key.position.set(4,6,2);
    const fill = new THREE.DirectionalLight(0x66ffd2, 0.35); fill.position.set(-5,2,-3);
    const rim  = new THREE.DirectionalLight(0x8b86ff, 0.9); rim.position.set(0,3.5,-6);
    scene.add(hemi,key,fill,rim);

    /* ===== helpers ===== */
    const rand=(a,b)=>a+Math.random()*(b-a);
    const choose=a=>a[(Math.random()*a.length)|0];

    /* ===== god rays (unchanged) ===== */
    function makeGodRay(){
      const geo = new THREE.ConeGeometry(6.5,16,64,1,true);
      geo.rotateX(-Math.PI/2);
      const mat = new THREE.ShaderMaterial({
        transparent:true, depthWrite:false, blending:THREE.AdditiveBlending,
        uniforms:{ uTime:{value:0}, uTint:{value:new THREE.Color(0xbfe8ff)}, uOpacity:{value:0.16}},
        vertexShader:`varying vec2 vUv; void main(){ vUv=uv; gl_Position=projectionMatrix*modelViewMatrix*vec4(position,1.0); }`,
        fragmentShader:`precision mediump float; varying vec2 vUv; uniform vec3 uTint; uniform float uTime,uOpacity;
          void main(){ float r=1.0-vUv.y; float radial=smoothstep(0.0,0.6,r)*(1.0-smoothstep(0.6,1.0,r));
            float band=0.5+0.5*sin(vUv.x*22.0+uTime*0.4);
            float a=radial*(0.35+0.65*band)*(1.0-vUv.x*0.6)*uOpacity; if(a<0.01) discard; gl_FragColor=vec4(uTint,a); }`
      });
      const m=new THREE.Mesh(geo,mat);
      m.position.set(rand(-2,2),5.8,rand(-1.5,1.5));
      m.rotation.z=rand(-0.15,0.15);
      m.userData.speed=rand(0.3,0.7);
      return m;
    }
    const RAYS=[]; for(let i=0;i<4;i++){ const r=makeGodRay(); RAYS.push(r); world.add(r); }

    /* ===== bubbles (speech) ===== */
    function makeBubbleSprite(text){
      const w=256,h=128, cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h;
      const ctx=cvs.getContext('2d');
      draw(text);
      function draw(t){
        ctx.clearRect(0,0,w,h);
        ctx.fillStyle='rgba(0,0,0,0.26)';
        ctx.strokeStyle='rgba(220,255,250,0.78)'; ctx.lineWidth=2;
        roundRect(ctx,8,8,w-16,h-16,14,true,true);
        ctx.font='600 22px ui-monospace, monospace';
        ctx.fillStyle='rgba(235,255,250,0.98)'; ctx.textAlign='center'; ctx.textBaseline='middle';
        wrapText(ctx,t,w/2,h/2,w-36,28);
      }
      const tex=new THREE.CanvasTexture(cvs);
      const mat=new THREE.SpriteMaterial({map:tex, transparent:true, depthWrite:false, opacity:1});
      const spr=new THREE.Sprite(mat); spr.scale.set(2.2,1.1,1);
      spr.userData={cvs,ctx,tex,draw};
      return spr;
    }
    function updateBubbleText(sprite, text){ sprite.userData.draw(text); sprite.userData.tex.needsUpdate=true; }
    function roundRect(ctx,x,y,w,h,r,fill,stroke){
      ctx.beginPath(); ctx.moveTo(x+r,y);
      ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r);
      ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
      if(fill)ctx.fill(); if(stroke)ctx.stroke();
    }
    function wrapText(ctx,text,x,y,maxWidth,lineHeight){
      const words=text.split(' '); const lines=[]; let line='';
      for(const w of words){ const test=line?line+' '+w:w; if(ctx.measureText(test).width>maxWidth){ lines.push(line); line=w; } else line=test; }
      if(line)lines.push(line);
      const total=lines.length*lineHeight; let cy=y-total/2+lineHeight/2;
      for(const l of lines){ ctx.fillText(l,x,cy); cy+=lineHeight; }
    }

    /* ===== fish shader ===== */
    const FishSandMaterial = (sheenColor)=>new THREE.ShaderMaterial({
      transparent:true, depthWrite:true,
      uniforms:{
        uLightDir:{value:new THREE.Vector3().copy(key.position).normalize()},
        uDark:{value:new THREE.Color(0x0a0f15)},
        uSheen:{value:sheenColor.clone()},
        uOpacity:{value:1.0}, uTime:{value:0}, uGrain:{value:96.0},
        uSpecPow:{value:64.0}, uRimPow:{value:2.4}, uRimStr:{value:0.42}
      },
      vertexShader:`precision mediump float; varying vec3 vN; varying vec3 vW; varying vec2 vUv;
        void main(){ vN=normalize(normalMatrix*normal); vec4 wp=modelMatrix*vec4(position,1.0);
          vW=wp.xyz; vUv=uv; gl_Position=projectionMatrix*viewMatrix*wp; }`,
      fragmentShader:`precision mediump float; varying vec3 vN; varying vec3 vW; varying vec2 vUv;
        uniform vec3 uLightDir,uDark,uSheen; uniform float uOpacity,uTime,uGrain,uSpecPow,uRimPow,uRimStr;
        float hash(vec3 p){ p=fract(p*0.3183099+vec3(0.1,0.2,0.3)); p+=dot(p,p.yzx+19.19); return fract((p.x+p.y)*p.z); }
        float grain(vec3 p){ float g=hash(p*uGrain); g=mix(g,hash(p*uGrain*1.7),0.5); g=mix(g,hash(p*uGrain*2.3),0.35); return g; }
        void main(){
          vec3 N=normalize(vN), L=normalize(uLightDir), V=normalize(cameraPosition-vW), H=normalize(L+V);
          float diffuse=pow(max(dot(N,L),0.0),1.2);
          float spec=pow(max(dot(N,H),0.0),uSpecPow);
          float rim=pow(1.0-max(dot(N,V),0.0),uRimPow)*uRimStr;
          float g=grain(vW+vec3(0.0,uTime*0.15,0.0));
          vec3 colDark=uDark*mix(0.55,1.0,g);
          vec3 colSheen=uSheen*(0.33+0.67*diffuse)*mix(0.80,1.25,g);
          vec3 color=mix(colDark,colSheen,diffuse)+spec*(uSheen*0.85+vec3(0.08,0.1,0.12))+rim*vec3(0.25,0.28,0.45);
          gl_FragColor=vec4(color,uOpacity); if(gl_FragColor.a<0.02) discard;
        }`
    });

    /* ===== UV helper ===== */
    function ensureSphericalUVs(geo){
      if(geo.attributes.uv) return;
      const pos=geo.attributes.position, uv=new Float32Array(pos.count*2), v=new THREE.Vector3();
      for(let i=0;i<pos.count;i++){ v.fromBufferAttribute(pos,i).normalize();
        const u=0.5+Math.atan2(v.z,v.x)/(2*Math.PI), w=0.5-Math.asin(v.y)/Math.PI;
        uv[i*2]=u; uv[i*2+1]=w; }
      geo.setAttribute('uv', new THREE.BufferAttribute(uv,2)); geo.attributes.uv.needsUpdate=true;
    }

    /* ===== palette from image #2 ===== */
    const PALETTE=[
      new THREE.Color('#aa4158'),
      new THREE.Color('#eeb3ad'),
      new THREE.Color('#dccfc2'),
      new THREE.Color('#364e88'),
      new THREE.Color('#2b2845')
    ];
    const TOTAL_FISH=24;

    /* ===== fish ===== */
    const PHRASES=['i am not real','today i forgot myself','be kind to the void','do fish dream?','404: meaning not found','blink slowly','pretend to be water','becoming … becoming','a small thought floats'];
    const BOUNDS={x:5.8,y:2.9,z:3.8};

    function makeFishMesh(sheenColor){
      const g=new THREE.Group(); g.userData.isFish=true;

      // body
      const radius=rand(0.25,0.38), sx=rand(1.7,2.2);
      const bodyGeo=new THREE.IcosahedronGeometry(radius,0); bodyGeo.computeVertexNormals(); bodyGeo.scale(sx,1,1);
      ensureSphericalUVs(bodyGeo);
      const body=new THREE.Mesh(bodyGeo, FishSandMaterial(sheenColor)); g.add(body);

      // 1) SOLID tail cone, tip attached (hinge), base wags
      const tailLen=0.38;
      const tailGeo=new THREE.ConeGeometry(0.20, tailLen, 12, 1, false); // <-- openEnded=false (solid)
      tailGeo.translate(0, -tailLen*0.5, 0);  // tip at y=0
      tailGeo.rotateZ(-Math.PI/2);            // point along +X
      const tailMesh=new THREE.Mesh(tailGeo, FishSandMaterial(sheenColor));

      const tailPivot=new THREE.Group(); tailPivot.add(tailMesh);
      const bodyMinX=-radius*sx;
      tailPivot.position.set(bodyMinX-0.06,0,0);
      g.add(tailPivot);

      // fins
      const finGeo=new THREE.ConeGeometry(0.08,0.18,5); finGeo.translate(0,-0.09,0);
      const finL=new THREE.Mesh(finGeo, FishSandMaterial(sheenColor));
      const finR=new THREE.Mesh(finGeo, FishSandMaterial(sheenColor));
      finL.position.set(0.08,-0.05, 0.16); finL.rotation.z=-Math.PI/2.6;
      finR.position.set(0.08,-0.05,-0.16); finR.rotation.z=-Math.PI/2.6; finR.rotation.y=Math.PI;
      g.add(finL,finR);

      // eyes
      const eyeGeo=new THREE.SphereGeometry(0.038,12,12);
      const eyeMat=new THREE.MeshStandardMaterial({color:0xffffff, roughness:0.25, metalness:0.1, transparent:true, opacity:1});
      const eyeL=new THREE.Mesh(eyeGeo,eyeMat), eyeR=new THREE.Mesh(eyeGeo,eyeMat);
      eyeL.position.set(0.42,0.06,0.12); eyeR.position.set(0.42,0.06,-0.12); g.add(eyeL,eyeR);

      // idle bubble
      const bubble=makeBubbleSprite(choose(PHRASES)); bubble.position.set(0,0.9,0); g.add(bubble);

      g.userData={
        isFish:true, body, tailPivot, tailMesh, fins:[finL,finR], eyes:[eyeL,eyeR], bubble,
        mats:[body.material, tailMesh.material, finL.material, finR.material]
      };
      return g;
    }

    class Fish{
      constructor(i){
        const sheen=PALETTE[i%PALETTE.length].clone();
        this.group=makeFishMesh(sheen); world.add(this.group);
        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel=new THREE.Vector3(rand(-0.02,0.02), rand(-0.01,0.01), rand(-0.015,0.015));
        this.turn=new THREE.Vector3(rand(-0.001,0.001), rand(-0.001,0.001), rand(-0.001,0.001));
        this.speed=rand(0.003,0.018); this.phase=Math.random()*Math.PI*2;
        this.paused=false; this.fading=false; this.fade=1.0; this.pauseTimer=0;
        this.memoryBubble=null;
      }
      update(dt,t){
        if(!this.group) return;

        if(this.paused && !this.fading){ this.pauseTimer+=dt; if(this.pauseTimer>=0.15) this.fading=true; }

        if(!this.paused){
          this.vel.addScaledVector(this.turn, dt).clampLength(0,this.speed);
          this.group.position.addScaledVector(this.vel, dt*60);
        }

        const p=this.group.position, v=this.vel;
        if(p.x<-BOUNDS.x){p.x=-BOUNDS.x; v.x=Math.abs(v.x);} if(p.x>BOUNDS.x){p.x=BOUNDS.x; v.x=-Math.abs(v.x);}
        if(p.y<-BOUNDS.y){p.y=-BOUNDS.y; v.y=Math.abs(v.y);} if(p.y>BOUNDS.y){p.y=BOUNDS.y; v.y=-Math.abs(v.y);}
        if(p.z<-BOUNDS.z){p.z=-BOUNDS.z; v.z=Math.abs(v.z);} if(p.z>BOUNDS.z){p.z=BOUNDS.z; v.z=-Math.abs(v.z);}

        const dir=this.vel.clone().normalize();
        if(dir.lengthSq()>1e-4){
          const q=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0), dir);
          this.group.quaternion.slerp(q,0.08);
        }

        const wag=Math.sin(t*6.0+this.phase)*0.35;
        this.group.userData.tailPivot.rotation.y=this.paused?0:wag;
        this.group.userData.fins.forEach((fin,i)=>{ fin.rotation.y=this.paused?0:Math.sin(t*5.5+this.phase+i)*0.12; });

        this.group.userData.bubble.lookAt(camera.position);
        for(const m of this.group.userData.mats){ m.uniforms.uTime.value=t; }

        if(this.fading){
          // create memory bubble once and manage its own fade timeline
          if(!this.memoryBubble){
            this.group.userData.bubble.material.opacity=0;
            const spr=makeBubbleSprite('i will remember this.');
            spr.material.opacity=0;
            spr.position.copy(this.group.localToWorld(new THREE.Vector3(0,0.9,0)));
            world.add(spr);
            this.memoryBubble={sprite:spr, t:0}; // t = life seconds
          }

          // fade fish
          this.fade=Math.max(0,this.fade-dt*0.9);
          for(const m of this.group.userData.mats){ m.uniforms.uOpacity.value=this.fade; }
          this.group.userData.eyes.forEach(e=> e.material.opacity=this.fade);

          // 2) memory bubble: fade-in -> linger -> fade-out always
          if(this.memoryBubble){
            const MB_IN=0.18, MB_LINGER=0.9, MB_OUT=0.8;
            this.memoryBubble.t+=dt;
            const s=this.memoryBubble.sprite;
            if(this.memoryBubble.t<MB_IN){
              s.material.opacity=THREE.MathUtils.lerp(s.material.opacity,1,0.35);
            }else if(this.memoryBubble.t<MB_IN+MB_LINGER){
              s.material.opacity=1;
            }else{
              s.material.opacity=Math.max(0, s.material.opacity - dt*(1/MB_OUT));
              if(s.material.opacity<=0){
                world.remove(s); s.material.map.dispose(); s.material.dispose();
                this.memoryBubble=null;
              }
            }
          }

          if(this.fade<=0){
            world.remove(this.group);
            this.group.traverse(o=>{
              if(o.material){ o.material.dispose?.(); o.material.map?.dispose?.(); }
              if(o.geometry){ o.geometry.dispose?.(); }
            });
            this.group=null;
          }
        }
      }
      triggerFade(){ if(!this.fading && this.group){ this.paused=true; this.pauseTimer=0; } }
    }

    const FISH=[]; for(let i=0;i<TOTAL_FISH;i++) FISH.push(new Fish(i));

    // random idle thoughts
    setInterval(()=>{
      const alive=FISH.filter(f=>f.group && !f.fading);
      if(!alive.length) return;
      updateBubbleText(choose(alive).group.userData.bubble, choose(PHRASES));
    },2000);

    /* ===== water particles ===== */
    const bubbleCount=220, bubbleGeo=new THREE.BufferGeometry();
    const positions=new Float32Array(bubbleCount*3), speeds=new Float32Array(bubbleCount), xDrifts=new Float32Array(bubbleCount);
    for(let i=0;i<bubbleCount;i++){ positions[i*3]=rand(-6,6); positions[i*3+1]=rand(-3,3); positions[i*3+2]=rand(-4,4);
      speeds[i]=rand(0.12,0.45); xDrifts[i]=rand(-0.15,0.15); }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(positions,3));
    const bubbleMat=new THREE.PointsMaterial({color:0xdff9ff, size:0.06, sizeAttenuation:true, transparent:true, opacity:0.7, depthWrite:false, blending:THREE.AdditiveBlending});
    const bubbles=new THREE.Points(bubbleGeo,bubbleMat); world.add(bubbles);
    function updateBubbles(dt){
      const arr=bubbleGeo.attributes.position.array;
      for(let i=0;i<bubbleCount;i++){
        let x=arr[i*3], y=arr[i*3+1], z=arr[i*3+2];
        y+=speeds[i]*dt; x+=xDrifts[i]*dt*0.4;
        if(y>3.2){ y=-3.2; x=rand(-6,6); z=rand(-4,4); speeds[i]=rand(0.12,0.45); xDrifts[i]=rand(-0.15,0.15); }
        arr[i*3]=x; arr[i*3+1]=y; arr[i*3+2]=z;
      }
      bubbleGeo.attributes.position.needsUpdate=true;
    }

    /* ===== shark ===== */
    const SHARK_SRC='shark.png';
    class Shark{
      constructor(){ this.mesh=null; this.dir=1; this.speed=0.55; this.y=rand(0.4,1.2); this.z=-4.2; this.phase=Math.random()*Math.PI*2; this.flipBound=12.5;
        new THREE.TextureLoader().load(SHARK_SRC, tex=>{
          tex.colorSpace=THREE.SRGBColorSpace; tex.premultiplyAlpha=true; tex.generateMipmaps=false;
          tex.minFilter=THREE.LinearFilter; tex.magFilter=THREE.LinearFilter;
          const aspect=tex.image.width/tex.image.height, W=11.0, H=W/aspect;
          const mat=new THREE.MeshBasicMaterial({map:tex, transparent:true, opacity:0.82, depthWrite:false, fog:false, side:THREE.DoubleSide, alphaTest:0.02});
          this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(W,H),mat);
          this.mesh.position.set(-this.flipBound-0.2,this.y,this.z); world.add(this.mesh);
        });
      }
      update(dt,t){ if(!this.mesh) return;
        this.mesh.position.x+=this.dir*this.speed*dt;
        this.mesh.position.y=this.y+Math.sin(t*0.25+this.phase)*0.12;
        if(this.dir>0 && this.mesh.position.x>this.flipBound){ this.dir=-1; this.mesh.rotation.y=Math.PI; }
        else if(this.dir<0 && this.mesh.position.x<-this.flipBound){ this.dir=1; this.mesh.rotation.y=0; }
      }
    }
    const SHARK=new Shark();

    /* ===== 3) natural curved parallax via camera rig ===== */
    let mouseX=0; // -1..1
    const yawRange=THREE.MathUtils.degToRad(8);  // how far we can look left/right
    const lateral=0.6;                           // slight lateral slide for depth
    const rollRange=THREE.MathUtils.degToRad(1.5);
    addEventListener('pointermove',(e)=>{
      mouseX = THREE.MathUtils.clamp((e.clientX/innerWidth)*2-1, -1, 1);
    });

    /* ===== click to fade fish ===== */
    const ray=new THREE.Raycaster(), m2=new THREE.Vector2();
    addEventListener('pointerdown',(e)=>{
      m2.x=(e.clientX/innerWidth)*2-1; m2.y=-(e.clientY/innerHeight)*2+1;
      ray.setFromCamera(m2,camera);
      const meshes=[]; world.traverse(o=>{ if(o.userData?.isFish) o.traverse(c=>{ if(c.isMesh) meshes.push(c); }); });
      const hit=ray.intersectObjects(meshes,true)[0];
      if(hit){ let root=hit.object; while(root.parent && !root.userData?.isFish) root=root.parent;
        const fish=FISH.find(f=>f.group===root); fish?.triggerFade(); }
    });

    /* ===== resize ===== */
    addEventListener('resize',()=>{
      camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); renderer.setSize(innerWidth,innerHeight);
    });

    /* ===== animate ===== */
    let last=performance.now();
    function tick(now){
      const dt=Math.min((now-last)/1000,0.05); last=now; const t=now*0.001;

      // god rays drift
      for(const r of RAYS){ r.material.uniforms.uTime.value=t;
        r.position.x+=Math.sin(t*r.userData.speed+r.id)*0.0008;
        r.position.z+=Math.cos(t*r.userData.speed+r.id)*0.0006; }

      // CURVED LOOK: rotate rig (yaw), slight roll, tiny lateral translation
      const targetYaw = mouseX * yawRange;
      const targetRoll = -mouseX * rollRange;            // subtle counter-roll
      const targetX = Math.sin(targetYaw) * lateral;     // arc-based slide

      rig.rotation.y = THREE.MathUtils.lerp(rig.rotation.y, targetYaw, 0.08);
      rig.rotation.z = THREE.MathUtils.lerp(rig.rotation.z, targetRoll, 0.08);
      rig.position.x = THREE.MathUtils.lerp(rig.position.x, targetX, 0.08);

      for(const f of FISH) f.update(dt,t);
      SHARK.update(dt,t);
      updateBubbles(dt);

      renderer.render(scene,camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
