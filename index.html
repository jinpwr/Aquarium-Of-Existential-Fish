<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background: linear-gradient(to bottom, #caecff 0%, #7aa0ff 40%, #180046 100%);
      animation: bgBluePulse 90s ease-in-out infinite;
    }
    @keyframes bgBluePulse {
      0%   { background: linear-gradient(to bottom, #caecff 0%, #7aa0ff 40%, #180046 100%); }
      50%  { background: linear-gradient(to bottom, #bcd9ff 0%, #6b8cff 40%, #1a0a4a 100%); }
      100% { background: linear-gradient(to bottom, #caecff 0%, #7aa0ff 40%, #180046 100%); }
    }
    canvas { position: relative; z-index: 0; display: block; }
    #dither {
      position: fixed; inset: 0; pointer-events: none; opacity: .12; z-index: 1;
      background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="black" opacity="0"/><rect x="0" y="0" width="2" height="2" fill="white" opacity="0.07"/><rect x="2" y="2" width="2" height="2" fill="white" opacity="0.07"/></svg>');
      image-rendering: pixelated; background-size: 4px; mix-blend-mode: overlay;
    }
    #overlay {
      position: fixed; inset: 0; pointer-events: none; z-index: 3;
      display: flex; align-items: flex-end; justify-content: space-between;
      padding: 12px 14px;
      font-family: ui-monospace, Menlo, Consolas, monospace;
      color: #b3f4ff;
      text-shadow: 0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .hint { opacity: .9; font-size: 12px; }
    #overlay .title { margin-left: auto; font-weight: 700; letter-spacing: .5px; font-size: 12px; color: #9effc7; }
  </style>
</head>
<body>
  <div id="dither"></div>
  <div id="overlay">
    <div class="hint">Move mouse: parallax · Click fish: freeze/vanish · <kbd>H</kbd>: hide bubbles</div>
    <div class="title">Aquarium of Existential Fish</div>
  </div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x120022, 0.05);

    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(innerWidth, innerHeight);
    renderer.setClearColor(0x000000, 0);
    document.body.appendChild(renderer.domElement);

    const hemi = new THREE.HemisphereLight(0xb9ecff, 0x180020, 0.48);
    scene.add(hemi);
    const key  = new THREE.PointLight(0x64d8ff, 16, 80, 2.0); key.position.set(6,4,3);   scene.add(key);
    const fill = new THREE.PointLight(0x4dffc8,  8, 80, 2.0); fill.position.set(-6,-1,-2); scene.add(fill);
    const rim  = new THREE.PointLight(0x5d5aff, 12,100, 2.2); rim.position.set(0,3.5,-8);  scene.add(rim);

    const rand = (a,b)=> a + Math.random()*(b-a);
    const choose = arr => arr[(Math.random()*arr.length)|0];

    /* Fish */
    function makeFishMesh(){
      const g = new THREE.Group();
      const hue = Math.random();
      const makeMat = h => new THREE.MeshStandardMaterial({
        color: new THREE.Color().setHSL(h, 0.92, 0.66),
        emissive: new THREE.Color().setHSL(h, 0.92, 0.33),
        emissiveIntensity: 0.75,
        roughness: 0.42,
        metalness: 0.18,
        flatShading: true
      });
      const body = new THREE.Mesh(new THREE.IcosahedronGeometry(0.35, 0), makeMat(hue));
      const tail = new THREE.Mesh(new THREE.ConeGeometry(0.2, 0.35, 3), makeMat(hue+0.1));
      tail.rotateZ(Math.PI/2); tail.position.x = -0.6;
      g.add(body, tail);
      return g;
    }

    class Fish {
      constructor(){
        this.group = new THREE.Group();
        this.mesh = makeFishMesh();
        this.group.add(this.mesh);
        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel = new THREE.Vector3(rand(-0.02,0.02), rand(-0.01,0.01), rand(-0.015,0.015));
        this.speed = rand(0.003, 0.018);
        scene.add(this.group);
      }
      update(dt){
        this.group.position.addScaledVector(this.vel, dt * 60);
        const p = this.group.position;
        if (p.x < -6 || p.x > 6) this.vel.x *= -1;
        if (p.y < -3 || p.y > 3) this.vel.y *= -1;
        if (p.z < -4 || p.z > 4) this.vel.z *= -1;
      }
    }
    const FISH = []; for (let i=0; i<18; i++) FISH.push(new Fish());

    /* Floating bubbles */
    const bubbleCount = 200;
    const bubbleGeo = new THREE.BufferGeometry();
    const pos = new Float32Array(bubbleCount * 3);
    const speed = new Float32Array(bubbleCount);
    for (let i=0;i<bubbleCount;i++){
      pos[i*3]=rand(-6,6); pos[i*3+1]=rand(-3,3); pos[i*3+2]=rand(-4,4); speed[i]=rand(0.12,0.45);
    }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    const bubbleMat = new THREE.PointsMaterial({color:0xdff9ff,size:0.06,transparent:true,opacity:0.7,depthWrite:false});
    const bubbles = new THREE.Points(bubbleGeo,bubbleMat); scene.add(bubbles);
    function updateBubbles(dt){
      const arr = bubbleGeo.attributes.position.array;
      for(let i=0;i<bubbleCount;i++){
        arr[i*3+1]+=speed[i]*dt;
        if(arr[i*3+1]>3.2){ arr[i*3+1]=-3.2; arr[i*3]=rand(-6,6); arr[i*3+2]=rand(-4,4); }
      }
      bubbleGeo.attributes.position.needsUpdate=true;
    }

    /* === Shark (PNG) === */
    const SHARK_SRC = 'shark.png';
    class BackgroundSharkPNG {
      constructor(){
        this.mesh = null;
        this.speed = 0.55;
        this.baseOpacity = 0.9;
        this.dir = 1; // start left->right
        this.phase = Math.random()*Math.PI*2;
        this.y = rand(0.2,1.2);
        this.z = -7.8;
        const loader = new THREE.TextureLoader();
        loader.load(SHARK_SRC, tex=>{
          tex.colorSpace = THREE.SRGBColorSpace;
          tex.premultiplyAlpha = true;
          tex.generateMipmaps = false;
          tex.minFilter = THREE.LinearFilter;
          tex.magFilter = THREE.LinearFilter;
          tex.needsUpdate = true;
          const mat = new THREE.MeshBasicMaterial({
            map: tex, transparent:true, opacity:this.baseOpacity,
            depthWrite:false, side:THREE.DoubleSide, alphaTest:0.03
          });
          const aspect = tex.image.width / tex.image.height;
          const W=9.5, H=W/aspect;
          const geo = new THREE.PlaneGeometry(W,H);
          this.mesh = new THREE.Mesh(geo,mat);
          scene.add(this.mesh);
          this.mesh.position.set(-12.5,this.y,this.z);
        });
      }
      update(dt,t){
        if(!this.mesh)return;
        // move horizontally
        this.mesh.position.x += this.dir*this.speed*dt;
        this.mesh.position.y = this.y + Math.sin(t*0.25+this.phase)*0.12;

        // flip when completely offscreen
        if(this.dir>0 && this.mesh.position.x>13.5){
          this.dir=-1;
          this.mesh.rotation.y=Math.PI; // flip horizontally
        } else if(this.dir<0 && this.mesh.position.x<-13.5){
          this.dir=1;
          this.mesh.rotation.y=0;
        }
      }
    }
    const SHARK = new BackgroundSharkPNG();

    /* Animation */
    let last=performance.now();
    function tick(now){
      const dt=Math.min((now-last)/1000,0.05); last=now;
      const t=now*0.001;
      FISH.forEach(f=>f.update(dt));
      updateBubbles(dt);
      SHARK.update(dt,t);
      renderer.render(scene,camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
