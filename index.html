<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Aquarium of Existential Fish</title>
  <style>
    html,body{
      height:100%;margin:0;overflow:hidden;
      /* base gradient: lighter top → darker bottom */
      background:linear-gradient(to bottom,#7fcde4 0%,#3b63c0 45%,#15053a 100%);
      /* smooth hue drift without visible jumps */
      animation:hueDrift 160s linear infinite alternate;
    }
    @keyframes hueDrift{
      0%   { filter: hue-rotate(0deg); }
      50%  { filter: hue-rotate(60deg); }
      100% { filter: hue-rotate(120deg); }
    }
    canvas{display:block}

    #overlay{
      position:fixed;inset:0;pointer-events:none;z-index:3;
      display:flex;align-items:flex-end;justify-content:flex-end;
      padding:12px 14px;
      font-family:ui-monospace,Menlo,Consolas,monospace;
      color:#b3f4ff;text-shadow:0 1px 2px rgba(0,0,0,.25);
    }
    #overlay .title{font-weight:700;letter-spacing:.5px;font-size:12px;color:#9effc7}
  </style>
</head>
<body>
  <div id="overlay"><div class="title">Aquarium of Existential Fish</div></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    /* ===== Scene / Renderer / Camera ===== */
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x0e0830, 0.06);

    const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
    camera.position.set(0, 2.2, 7);

    const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
    renderer.setPixelRatio(Math.min(devicePixelRatio,2));
    renderer.setSize(innerWidth, innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.6;
    document.body.appendChild(renderer.domElement);

    /* ===== Lights (cool blue) ===== */
    const hemi = new THREE.HemisphereLight(0xbfeaff, 0x0f1033, 0.7);
    const key  = new THREE.PointLight(0x7cd9ff, 26, 120, 1.8); key.position.set(5, 4, 6);
    const fill = new THREE.PointLight(0x6ff0d4, 10, 120, 1.8); fill.position.set(-5, 1.2, 5);
    const rim  = new THREE.PointLight(0x6b6bff, 16, 160, 2.2); rim.position.set(0, 3.6, -9);
    scene.add(hemi, key, fill, rim);

    /* ===== Utils ===== */
    const rand = (a,b) => a + Math.random()*(b-a);
    const choose = a => a[(Math.random()*a.length)|0];
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

    // Shortest-path angle interpolation
    function lerpAngle(a, b, t){
      let diff = (b - a + Math.PI) % (2*Math.PI) - Math.PI;
      return a + diff * t;
    }

    /* ===== Mouse: world projection + horizontal pan + avoidance ===== */
    const raycaster = new THREE.Raycaster();
    const mouseNDC = new THREE.Vector2();
    const plane    = new THREE.Plane(new THREE.Vector3(0,0,1), 0);
    const mouseWorld = new THREE.Vector3(999,999,0); // far away initially
    let mouseX = 0;
    const panRange = 1.4;

    addEventListener('mousemove', e=>{
      mouseX = (e.clientX/innerWidth)*2 - 1;
      mouseNDC.x = mouseX;
      mouseNDC.y = -(e.clientY/innerHeight)*2 + 1;
      raycaster.setFromCamera(mouseNDC, camera);
      raycaster.ray.intersectPlane(plane, mouseWorld);
    });

    /* ===== Thought bubbles ===== */
    const PHRASES = [
      "the sea forgets no one",
      "my reflection looks back too long",
      "light bends where i used to be",
      "every bubble is a thought escaping",
      "softly dissolving into memory",
      "the silence is breathing",
      "dreams taste like salt",
      "you were here once",
      "i hope the current remembers me",
      "where do ripples go to die?"
    ];

    function makeBubbleSprite(text){
      const w=256,h=128;
      const c=document.createElement('canvas'); c.width=w; c.height=h;
      const x=c.getContext('2d');

      // background + outline
      x.fillStyle='rgba(0,0,0,0.35)';
      x.strokeStyle='rgba(255,255,255,0.85)'; x.lineWidth=3;
      x.beginPath();
      x.moveTo(14,8);
      x.arcTo(w-8,8,w-8,h-8,14);
      x.arcTo(w-8,h-8,8,h-8,14);
      x.arcTo(8,h-8,8,8,14);
      x.arcTo(8,8,w-8,8,14);
      x.closePath(); x.fill(); x.stroke();

      // text
      x.font='600 22px ui-monospace, monospace';
      x.fillStyle='rgba(235,255,250,0.98)';
      x.textAlign='center'; x.textBaseline='middle';
      // wrap (quick two-line approach)
      const lines=[]; const words=text.split(' ');
      let line='';
      for(const w2 of words){
        const test=line?line+' '+w2:w2;
        if(x.measureText(test).width> w-36){ lines.push(line); line=w2; } else line=test;
      }
      if(line) lines.push(line);
      const startY = h/2 - (lines.length-1)*14;
      lines.forEach((L,i)=> x.fillText(L, w/2, startY + i*28));

      const tex=new THREE.CanvasTexture(c);
      const mat=new THREE.SpriteMaterial({ map:tex, transparent:true, depthWrite:false });
      const s=new THREE.Sprite(mat); s.scale.set(2.2,1.1,1);
      s.userData={ctx:x, texture:tex};
      return s;
    }

    /* ===== Fish materials & textures ===== */
    function fishTexture(seedHex){
      const w=512,h=256, cvs=document.createElement('canvas'); cvs.width=w; cvs.height=h;
      const g=cvs.getContext('2d');

      const base = new THREE.Color(seedHex);
      const belly= base.clone().lerp(new THREE.Color('#ffffff'), 0.55);
      const back = base.clone().lerp(new THREE.Color('#000000'), 0.35);

      const grad = g.createLinearGradient(0,0,0,h);
      grad.addColorStop(0.00, `#${belly.getHexString()}`);
      grad.addColorStop(0.50, `#${base.getHexString()}`);
      grad.addColorStop(1.00, `#${back.getHexString()}`);
      g.fillStyle = grad; g.fillRect(0,0,w,h);

      // bold-ish vertical stripes (still natural-ish)
      g.globalAlpha = 0.35;
      for(let x=0; x<w; x+=14){
        g.fillStyle = `rgba(255,255,255,${0.3 + Math.random()*0.2})`;
        g.fillRect(x, 0, 6, h);
      }
      g.globalAlpha = 1;

      // speckled scales
      for(let i=0;i<1400;i++){
        g.fillStyle=`rgba(255,255,255,${Math.random()*0.25})`;
        g.fillRect(Math.random()*w, Math.random()*h, 1.5, 1.5);
      }

      const tex = new THREE.CanvasTexture(cvs);
      tex.anisotropy = renderer.capabilities.getMaxAnisotropy();
      return tex;
    }

    function bodyMaterial(hex){
      return new THREE.MeshStandardMaterial({
        map: fishTexture(hex),
        color: 0xffffff,
        roughness: 0.3,
        metalness: 0.3,
        emissive: new THREE.Color(0x1a1a1a),
        emissiveIntensity: 0.3,
        transparent: true
      });
    }

    // Fins/tails: translucent with faint blue luminescent outline
    function finMaterial(baseHex){
      const col = new THREE.Color(baseHex).lerp(new THREE.Color('#ffffff'), 0.35);
      return new THREE.MeshStandardMaterial({
        color: col,
        roughness: 0.5,
        metalness: 0.15,
        emissive: new THREE.Color(0x3758ff),   // subtle blue glow
        emissiveIntensity: 0.15,
        transparent: true,
        opacity: 0.55,
        side: THREE.DoubleSide,
        blending: THREE.AdditiveBlending,
        depthWrite: false
      });
    }

    // Eyes: now transparent-aware so they fade with body
    function eyeMaterial(){
      return new THREE.MeshBasicMaterial({
        color: 0x000000,
        transparent: true,
        opacity: 1.0
      });
    }

    /* ===== Elegant fish model ===== */
    function createFishModel(hex){
      const group = new THREE.Group();

      // Body (elongated sphere)
      const body = new THREE.Mesh(
        new THREE.SphereGeometry(0.36, 24, 16),
        bodyMaterial(hex)
      );
      body.scale.set(1.9, 1.0, 0.85);
      group.add(body);

      // Forked tail (two long thin planes)
      const tailMat = finMaterial(hex);
      const tailW = 0.7, tailH = 0.5;
      const tailGeo = new THREE.PlaneGeometry(tailW, tailH, 1, 3);
      // add slight curve in geometry for flow
      const pos = tailGeo.attributes.position;
      for(let i=0; i<pos.count; i++){
        const y = pos.getY(i);
        const bend = (y / tailH) * 0.06;
        pos.setZ(i, bend);
      }
      pos.needsUpdate = true;

      const tailL = new THREE.Mesh(tailGeo, tailMat);
      const tailR = new THREE.Mesh(tailGeo, tailMat.clone());
      tailL.position.set(-1.0, 0.0, 0.12);
      tailR.position.set(-1.0, 0.0, -0.12);
      tailL.rotation.y = Math.PI * 0.5;
      tailR.rotation.y = Math.PI * 0.5;
      group.add(tailL, tailR);

      // Dorsal & ventral long fins (ribbons)
      const finGeo = new THREE.PlaneGeometry(0.9, 0.28, 1, 4);
      const finTop = new THREE.Mesh(finGeo, finMaterial(hex));
      const finBot = new THREE.Mesh(finGeo, finMaterial(hex));
      finTop.position.set(0.1, 0.22, 0.0);
      finBot.position.set(0.05, -0.22, 0.0);
      finTop.rotation.x = -Math.PI/12;
      finBot.rotation.x = Math.PI/12;
      group.add(finTop, finBot);

      // Pectoral fins (left/right)
      const pecGeo = new THREE.PlaneGeometry(0.4, 0.18, 1, 2);
      const pecL = new THREE.Mesh(pecGeo, finMaterial(hex));
      const pecR = new THREE.Mesh(pecGeo, finMaterial(hex));
      pecL.position.set(0.25, -0.08, 0.32);
      pecR.position.set(0.25, -0.08, -0.32);
      pecL.rotation.set(0, Math.PI/2.6,  Math.PI/12);
      pecR.rotation.set(0, -Math.PI/2.6, -Math.PI/12);
      group.add(pecL, pecR);

      // Eyes (small spheres)
      const eyeGeo = new THREE.SphereGeometry(0.04, 12, 12);
      const eyeL = new THREE.Mesh(eyeGeo, eyeMaterial());
      const eyeR = eyeL.clone();
      eyeL.position.set(0.55, 0.08, 0.17);
      eyeR.position.set(0.55, 0.08, -0.17);
      group.add(eyeL, eyeR);

      // Simple mouth: small dark disk scaling in/out to "gape"
      const mouth = new THREE.Mesh(
        new THREE.CircleGeometry(0.045, 16),
        new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.9 })
      );
      mouth.position.set(0.75, 0.02, 0.0);
      mouth.rotation.y = Math.PI/2;
      group.add(mouth);

      // Save references for animation
      group.userData = { body, tailL, tailR, finTop, finBot, pecL, pecR, mouth, eyes:[eyeL, eyeR] };
      return group;
    }

    /* ===== Fish class ===== */
    const BOUNDS = { x: 5.8, y: 2.9, z: 3.8 };

    class Fish {
      constructor(hex){
        this.group = createFishModel(hex);
        this.thought = makeBubbleSprite(choose(PHRASES));
        this.thought.position.set(0, 0.95, 0);
        this.group.add(this.thought);

        this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
        this.vel = new THREE.Vector3(rand(-0.02,0.02), rand(-0.01,0.01), rand(-0.015,0.015));
        this.speed = rand(0.004, 0.016);
        this.dead = false;

        // Animation phases
        this.tailPhase = Math.random() * Math.PI*2;
        this.finPhase  = Math.random() * Math.PI*2;
        this.mouthPhase= Math.random() * Math.PI*2;

        // For smooth heading interpolation
        this.heading = 0; // current yaw
        scene.add(this.group);
      }

      fade(){
        if (this.dead) return;
        this.dead = true;

        // Remove current thought bubble immediately to avoid overlap
        this.group.remove(this.thought); scene.remove(this.thought);

        const farewell = makeBubbleSprite("i will remember this.");
        farewell.position.copy(this.group.position).add(new THREE.Vector3(0,0.9,0));
        scene.add(farewell);

        const start = performance.now();
        const fadeOut = () => {
          const t = (performance.now() - start) / 1500; // 1.5s
          // Traverse all meshes, including eyes/fins/tails/body & mouth
          this.group.traverse(obj=>{
            if (obj.material) {
              obj.material.opacity = clamp(1 - t, 0, 1);
            }
          });
          if (t < 1) requestAnimationFrame(fadeOut);
          else scene.remove(this.group);
        };
        fadeOut();

        const msgStart = performance.now();
        const msgAnim = ()=>{
          const t = (performance.now() - msgStart) / 4000;
          farewell.position.y += 0.002;
          farewell.material.opacity = clamp(1 - t, 0, 1);
          if (t < 1) requestAnimationFrame(msgAnim);
          else scene.remove(farewell);
        };
        msgAnim();
      }

      update(dt, time){
        if (this.dead) return;

        // Gentle mouse avoidance
        const toMouse = new THREE.Vector3().subVectors(this.group.position, mouseWorld);
        const dist = toMouse.length();
        const radius = 3.0;
        if (Number.isFinite(dist) && dist < radius){
          const s = (radius - dist) / radius;
          toMouse.normalize();
          this.vel.addScaledVector(toMouse, s * 0.05);
        }

        // Apply velocity
        this.group.position.addScaledVector(this.vel, dt * 60);

        // Bounds bounce
        const p = this.group.position, v = this.vel;
        if (p.x < -BOUNDS.x){ p.x = -BOUNDS.x; v.x = Math.abs(v.x); }
        if (p.x >  BOUNDS.x){ p.x =  BOUNDS.x; v.x = -Math.abs(v.x); }
        if (p.y < -BOUNDS.y){ p.y = -BOUNDS.y; v.y = Math.abs(v.y); }
        if (p.y >  BOUNDS.y){ p.y =  BOUNDS.y; v.y = -Math.abs(v.y); }
        if (p.z < -BOUNDS.z){ p.z = -BOUNDS.z; v.z = Math.abs(v.z); }
        if (p.z >  BOUNDS.z){ p.z =  BOUNDS.z; v.z = -Math.abs(v.z); }

        // Smooth turn toward movement direction (yaw about Y)
        const dir = this.vel.clone().normalize();
        if (dir.lengthSq() > 0.00001){
          const targetYaw = Math.atan2(-dir.z, dir.x); // +X is forward
          this.heading = lerpAngle(this.heading, targetYaw, clamp(2.5*dt, 0, 1)); // turn rate
          this.group.rotation.y = this.heading;

          // tiny roll for life
          this.group.rotation.z = Math.sin(time*0.8 + this.tailPhase)*0.03;
        }

        // Animate mouth (gentle gape)
        const { mouth, tailL, tailR, finTop, finBot, pecL, pecR } = this.group.userData;
        const mouthOpen = (Math.sin(time*2.0 + this.mouthPhase)*0.5 + 0.5)*0.3 + 0.85; // 0.85..1.15
        mouth.scale.set(1, mouthOpen, 1);

        // Tail & fin wobble (realistic amplitude)
        const tailAngle = Math.sin(time*2.0 + this.tailPhase) * THREE.MathUtils.degToRad(10); // ~±10°
        tailL.rotation.z = tailAngle;
        tailR.rotation.z = -tailAngle;

        const finAng = Math.sin(time*1.6 + this.finPhase) * THREE.MathUtils.degToRad(5); // ~±5°
        finTop.rotation.z = finAng;
        finBot.rotation.z = -finAng;

        const pecAng = Math.sin(time*2.2 + this.finPhase)*THREE.MathUtils.degToRad(6);
        pecL.rotation.x = pecAng/2; pecR.rotation.x = -pecAng/2;

        // Keep thought bubble facing camera
        this.thought.lookAt(camera.position);
      }
    }

    /* ===== Build fish with distinct hues (14 total) ===== */
    const FISH = [];
    for (let i=0;i<14;i++){
      const col = new THREE.Color().setHSL(i/14, 0.85, 0.55);
      FISH.push( new Fish(`#${col.getHexString()}`) );
    }

    // Click-to-fade
    addEventListener('click', e=>{
      mouseNDC.x = (e.clientX/innerWidth)*2 - 1;
      mouseNDC.y = -(e.clientY/innerHeight)*2 + 1;
      raycaster.setFromCamera(mouseNDC, camera);

      // Intersect against all meshes inside fish groups (body is enough, but include others for reliability)
      const candidates = [];
      for (const f of FISH){
        f.group.traverse(obj=>{ if (obj.isMesh) candidates.push(obj); });
      }
      const hits = raycaster.intersectObjects(candidates, true);
      if (hits.length){
        const hit = hits[0].object;
        const fish = FISH.find(ff=>{
          let found=false;
          ff.group.traverse(o=>{ if(o===hit) found=true; });
          return found;
        });
        if (fish) fish.fade();
      }
    });

    /* ===== Water bubbles (particles) ===== */
    const bubbleCount = 220;
    const bubbleGeo = new THREE.BufferGeometry();
    const bPos = new Float32Array(bubbleCount*3);
    const bSpeed = new Float32Array(bubbleCount);
    for (let i=0;i<bubbleCount;i++){
      bPos[i*3+0] = rand(-6,6);
      bPos[i*3+1] = rand(-3,3);
      bPos[i*3+2] = rand(-4,4);
      bSpeed[i]   = rand(0.12,0.45);
    }
    bubbleGeo.setAttribute('position', new THREE.BufferAttribute(bPos,3));
    const bubbleMat = new THREE.PointsMaterial({
      color:0xdff9ff, size:0.06, sizeAttenuation:true,
      transparent:true, opacity:0.7, depthWrite:false, blending:THREE.AdditiveBlending
    });
    const bubbles = new THREE.Points(bubbleGeo, bubbleMat);
    scene.add(bubbles);
    function updateBubbles(dt){
      const arr=bubbleGeo.attributes.position.array;
      for(let i=0;i<bubbleCount;i++){
        arr[i*3+1]+=bSpeed[i]*dt;
        if(arr[i*3+1]>3.2){ arr[i*3+1]=-3.2; arr[i*3]=rand(-6,6); arr[i*3+2]=rand(-4,4); }
      }
      bubbleGeo.attributes.position.needsUpdate = true;
    }

    /* ===== Shark (PNG plane behind fish) ===== */
    const SHARK_SRC = 'shark.png';
    class Shark {
      constructor(){
        this.dir=1; this.speed=0.55;
        this.y=rand(0.2,1.2); this.z=-7.8;
        this.phase=Math.random()*Math.PI*2; this.flipBound=16.5;
        new THREE.TextureLoader().load(SHARK_SRC, t=>{
          t.colorSpace = THREE.SRGBColorSpace; t.premultiplyAlpha = true;
          const aspect=t.image.width/t.image.height, W=19, H=W/aspect;
          const m=new THREE.MeshBasicMaterial({ map:t, transparent:true, opacity:0.75, depthWrite:false, side:THREE.DoubleSide, alphaTest:0.03 });
          this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(W,H), m);
          this.mesh.position.set(-this.flipBound-0.2, this.y, this.z);
          scene.add(this.mesh);
        });
      }
      update(dt, t){
        if(!this.mesh) return;
        this.mesh.position.x += this.dir * this.speed * dt;
        this.mesh.position.y  = this.y + Math.sin(t*0.25 + this.phase)*0.12;
        if(this.dir>0 && this.mesh.position.x> this.flipBound){ this.dir=-1; this.mesh.rotation.y=Math.PI; }
        else if(this.dir<0 && this.mesh.position.x<-this.flipBound){ this.dir= 1; this.mesh.rotation.y=0; }
      }
    }
    const SHARK = new Shark();

    /* ===== Resize ===== */
    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });

    /* ===== Animate ===== */
    let last = performance.now();
    function tick(now){
      const dt = Math.min((now - last)/1000, 0.05); last = now;
      const t  = now * 0.001;

      // Horizontal camera pan for depth
      const targetX = mouseX * panRange;
      camera.position.x += (targetX - camera.position.x)*0.05;
      camera.lookAt(0,0,0);

      // Fish
      for(const f of FISH) f.update(dt, t);

      // Bubbles & shark
      updateBubbles(dt);
      SHARK.update(dt, t);

      renderer.render(scene, camera);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  </script>
</body>
</html>
