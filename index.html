<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Aquarium of Existential Fish</title>
<style>
  html,body{height:100%;margin:0;overflow:hidden}
  /* (2) Ocean gradient — lighter top → darker bottom */
  body{
    background:
      linear-gradient(to bottom,
        #0b1a27 0%,
        #0e2944 15%,
        #103b67 35%,
        #134b86 55%,
        #123d74 72%,
        #0c264a 86%,
        #09172c 100%
      );
  }
  canvas{display:block}

  #dither{
    position:fixed;inset:0;pointer-events:none;opacity:.12;z-index:2;
    background-image:url('data:image/svg;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="4" height="4"><rect width="4" height="4" fill="black" opacity="0"/><rect x="0" y="0" width="2" height="2" fill="white" opacity="0.08"/><rect x="2" y="2" width="2" height="2" fill="white" opacity="0.08"/></svg>');
    image-rendering:pixelated;background-size:4px;background-repeat:repeat;mix-blend-mode:overlay;
  }

  #instructions{
    position:fixed;left:12px;bottom:10px;z-index:4;pointer-events:none;
    font-family:ui-monospace,Menlo,Consolas,monospace;font-size:12px;line-height:1.5;
    color:#9effc7;text-shadow:0 1px 2px rgba(0,0,0,.3)
  }
</style>
</head>
<body>
<div id="dither"></div>
<div id="instructions">move mouse horizontally to look around / try clicking on a fish</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- Scene ---------- */
const scene = new THREE.Scene();
const world = new THREE.Group();
scene.add(world);
scene.fog = new THREE.FogExp2(0x0b1a27, 0.055);

const camera = new THREE.PerspectiveCamera(65, innerWidth/innerHeight, 0.1, 200);
camera.position.set(0, 2.0, 7);
camera.lookAt(0,0,0);

const renderer = new THREE.WebGLRenderer({ antialias:true, alpha:true });
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth, innerHeight);
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.toneMapping = THREE.ACESFilmicToneMapping;
renderer.toneMappingExposure = 0.9;
document.body.appendChild(renderer.domElement);

/* ---------- Lights ---------- */
const hemi = new THREE.HemisphereLight(0xaad9ff, 0x0b0018, 0.35);
const key  = new THREE.DirectionalLight(0xb0d6ff, 1.35); key.position.set(4,6,2);
const fill = new THREE.DirectionalLight(0x66ffd2, 0.35); fill.position.set(-5,2,-3);
const rim  = new THREE.DirectionalLight(0x8b86ff, 0.9);  rim.position.set(0,3.5,-6);
scene.add(hemi,key,fill,rim);

/* ---------- Helpers ---------- */
const rand=(a,b)=>a+Math.random()*(b-a);
const choose=arr=>arr[(Math.random()*arr.length)|0];

/* ---------- Bubble text (unchanged) ---------- */
function makeBubbleSprite(text){
  const w=256,h=128,c=document.createElement('canvas');c.width=w;c.height=h;
  const x=c.getContext('2d');
  const draw=(t)=>{
    x.clearRect(0,0,w,h);
    x.fillStyle='rgba(0,0,0,0.26)';
    x.strokeStyle='rgba(220,255,250,0.78)'; x.lineWidth=2;
    x.beginPath(); const r=14;
    x.moveTo(8+r,8);
    x.arcTo(w-8,8,w-8,h-8,r);
    x.arcTo(w-8,h-8,8,h-8,r);
    x.arcTo(8,h-8,8,8,r);
    x.arcTo(8,8,w-8,8,r); x.closePath();
    x.fill(); x.stroke();
    x.font='600 22px ui-monospace, monospace';
    x.fillStyle='rgba(235,255,250,0.98)'; x.textAlign='center'; x.textBaseline='middle';
    x.fillText(t,w/2,h/2);
  };
  draw(text);
  const tex=new THREE.CanvasTexture(c);
  const spr=new THREE.Sprite(new THREE.SpriteMaterial({map:tex,transparent:true,depthWrite:false,opacity:1}));
  spr.scale.set(2.2,1.1,1);
  spr.userData={canvas:c,ctx:x,texture:tex,draw};
  return spr;
}

/* ---------- Grainy fish material ---------- */
const FishMat=(sheen)=>new THREE.ShaderMaterial({
  transparent:true, depthWrite:true,
  uniforms:{
    uLightDir:{value:new THREE.Vector3().copy(key.position).normalize()},
    uDark:{value:new THREE.Color(0x0a0f15)},
    uSheen:{value:new THREE.Color(sheen)},
    uOpacity:{value:1.0}, uTime:{value:0},
    uGrain:{value:96.0}, uSpecPow:{value:64.0}, uRimPow:{value:2.4}, uRimStr:{value:0.42}
  },
  vertexShader:/*glsl*/`
    precision mediump float;
    varying vec3 vN; varying vec3 vW;
    void main(){
      vN = normalize(normalMatrix*normal);
      vec4 wp = modelMatrix*vec4(position,1.0);
      vW = wp.xyz;
      gl_Position = projectionMatrix*viewMatrix*wp;
    }`,
  fragmentShader:/*glsl*/`
    precision mediump float;
    varying vec3 vN; varying vec3 vW;
    uniform vec3 uLightDir,uDark,uSheen;
    uniform float uOpacity,uTime,uGrain,uSpecPow,uRimPow,uRimStr;
    float hash(vec3 p){ p=fract(p*0.3183099+vec3(0.1,0.2,0.3)); p+=dot(p,p.yzx+19.19); return fract((p.x+p.y)*p.z); }
    float grain(vec3 p){ float g=hash(p*uGrain); g=mix(g,hash(p*uGrain*1.7),.5); g=mix(g,hash(p*uGrain*2.3),.35); return g; }
    void main(){
      vec3 N=normalize(vN), L=normalize(uLightDir), V=normalize(cameraPosition - vW), H=normalize(L+V);
      float diff = pow(max(dot(N,L),0.0), 1.2);
      float spec = pow(max(dot(N,H),0.0), uSpecPow);
      float rim  = pow(1.0-max(dot(N,V),0.0), uRimPow)*uRimStr;
      float g = grain(vW+vec3(0.0,uTime*0.15,0.0));
      vec3 col = mix(uDark*(0.55+0.45*g), uSheen*(0.33+0.67*diff)*(0.8+0.45*g), diff);
      col += spec*(uSheen*0.85+vec3(0.08,0.1,0.12));
      col += rim*vec3(0.25,0.28,0.45);
      gl_FragColor = vec4(col, uOpacity);
      if(gl_FragColor.a<0.02) discard;
    }`
});

/* ---------- Palette from your image (4) ---------- */
const PALETTE = [
  '#9e2b3b', // deep red
  '#f1a7a0', // coral pink
  '#d9c9ba', // beige
  '#244a9b', // royal blue
  '#0f1033'  // navy (used sparingly)
];

/* ---------- Fish geometry with cone tail (1) ---------- */
const BOUNDS = { x: 5.8, y: 2.9, z: 3.8 };
const PHRASES = ['i will remember this.','blink slowly','pretend to be water','today i forgot myself'];

function makeFishMesh(colorHex){
  const g = new THREE.Group(); g.userData.isFish=true;

  // Body (icosahedron stretched on X)
  const r = rand(0.25,0.38), sx = rand(1.7,2.2);
  const bodyGeo = new THREE.IcosahedronGeometry(r,0); bodyGeo.computeVertexNormals(); bodyGeo.scale(sx,1,1);
  const bodyMat = FishMat(colorHex); const body = new THREE.Mesh(bodyGeo, bodyMat); g.add(body);

  // --- Cone tail: TIP anchored to body, BASE wags ---
  const tailLen = 0.42, tailRad = 0.22;
  const rawCone = new THREE.ConeGeometry(tailRad, tailLen, 12); // axis +Y
  rawCone.translate(0, tailLen/2, 0);      // move so TIP is at (0,0,0), base at +Y
  rawCone.rotateZ(Math.PI/2);              // align along +X
  const tailMat = FishMat(colorHex);
  const tail = new THREE.Mesh(rawCone, tailMat);

  const tailPivot = new THREE.Group();     // rotate around TIP (attached point)
  tailPivot.add(tail);
  // attach tip to body's leftmost point
  const tipOffsetX = -r*sx - 0.06;
  tailPivot.position.set(tipOffsetX, 0, 0);
  g.add(tailPivot);

  // Pectoral fins (small triangles)
  const finGeo=new THREE.ConeGeometry(0.08,0.18,5); finGeo.translate(0,0.09,0); finGeo.rotateZ(-Math.PI/2.5);
  const finL=new THREE.Mesh(finGeo, FishMat(colorHex));
  const finR=new THREE.Mesh(finGeo, FishMat(colorHex)); finR.scale.y = -1;
  finL.position.set(0.10,-0.04, 0.16); finR.position.set(0.10,-0.04,-0.16);
  g.add(finL,finR);

  // Eyes
  const eyeGeo=new THREE.SphereGeometry(0.038,12,12);
  const eyeMat=new THREE.MeshStandardMaterial({ color:0xffffff, roughness:0.25, metalness:0.1, transparent:true, opacity:1 });
  const eyeL=new THREE.Mesh(eyeGeo,eyeMat), eyeR=new THREE.Mesh(eyeGeo,eyeMat);
  eyeL.position.set(0.42,0.06,0.12); eyeR.position.set(0.42,0.06,-0.12); g.add(eyeL,eyeR);

  // Idle thought bubble
  const bubble=makeBubbleSprite(choose(PHRASES)); bubble.position.set(0,0.9,0); g.add(bubble);

  g.userData={isFish:true, body, tailPivot, tail, fins:[finL,finR], eyes:[eyeL,eyeR],
              mats:[bodyMat, tailMat, finL.material, finR.material], bubble};
  return g;
}

class Fish{
  constructor(i){
    const color = PALETTE[i % PALETTE.length];
    this.group = makeFishMesh(color); world.add(this.group);
    this.group.position.set(rand(-4,4), rand(-1.2,2.2), rand(-2.5,2.5));
    this.vel=new THREE.Vector3(rand(-0.02,0.02), rand(-0.01,0.01), rand(-0.015,0.015));
    this.turn=new THREE.Vector3(rand(-0.001,0.001), rand(-0.001,0.001), rand(-0.001,0.001));
    this.speed=rand(0.003,0.018);
    this.phase=Math.random()*Math.PI*2;
    this.fading=false; this.fade=1.0; this.paused=false; this.pauseTimer=0; this.memoryBubble=null;
  }
  update(dt,t){
    if(!this.group) return;

    if(this.paused && !this.fading){ this.pauseTimer+=dt; if(this.pauseTimer>=0.12) this.fading=true; }

    if(!this.paused){
      this.vel.x+=this.turn.x*dt; this.vel.y+=this.turn.y*dt; this.vel.z+=this.turn.z*dt;
      this.vel.clampLength(0,this.speed);
      this.group.position.addScaledVector(this.vel, dt*60);
    }

    const p=this.group.position, v=this.vel;
    if(p.x<-BOUNDS.x){p.x=-BOUNDS.x;v.x=Math.abs(v.x)} if(p.x>BOUNDS.x){p.x=BOUNDS.x;v.x=-Math.abs(v.x)}
    if(p.y<-BOUNDS.y){p.y=-BOUNDS.y;v.y=Math.abs(v.y)} if(p.y>BOUNDS.y){p.y=BOUNDS.y;v.y=-Math.abs(v.y)}
    if(p.z<-BOUNDS.z){p.z=-BOUNDS.z;v.z=Math.abs(v.z)} if(p.z>BOUNDS.z){p.z=BOUNDS.z;v.z=-Math.abs(v.z)}

    const dir=this.vel.clone().normalize();
    if(dir.lengthSq()>0.0001){
      const targetQuat=new THREE.Quaternion().setFromUnitVectors(new THREE.Vector3(1,0,0),dir);
      this.group.quaternion.slerp(targetQuat,0.08);
    }

    // Tail wag around TIP (pivot), base swings
    const wag = Math.sin(t*6.0 + this.phase) * 0.35;
    this.group.userData.tailPivot.rotation.y = this.paused ? 0 : wag;

    // Fins flutter
    this.group.userData.fins.forEach((fin,i)=>{
      fin.rotation.y = this.paused ? 0 : Math.sin(t*5.5 + this.phase + i)*0.12;
    });

    this.group.userData.bubble.lookAt(camera.position);
    for(const m of this.group.userData.mats){ m.uniforms.uTime.value=t; }

    // Fade logic (click)
    if(this.fading){
      if(!this.memoryBubble){
        this.group.userData.bubble.material.opacity = 0;
        const mem = makeBubbleSprite('i will remember this.');
        const pos = this.group.localToWorld(new THREE.Vector3(0,0.9,0));
        mem.position.copy(pos); mem.material.opacity=1; world.add(mem);
        this.memoryBubble = {sprite:mem,life:0};
      }
      this.fade=Math.max(0,this.fade-dt*0.9);
      for(const m of this.group.userData.mats){ m.uniforms.uOpacity.value=this.fade; }
      this.group.userData.eyes.forEach(e=>e.material.opacity=this.fade);
      if(this.fade<=0){
        world.remove(this.group);
        this.group.traverse(o=>{
          o.material?.dispose?.(); o.material?.map?.dispose?.(); o.geometry?.dispose?.();
        });
        this.group=null;
      }
    }
  }
  triggerFade(){ if(!this.fading && this.group){ this.paused=true; this.pauseTimer=0; } }
}

const FISH=[]; const TOTAL=24; for(let i=0;i<TOTAL;i++) FISH.push(new Fish(i));

/* ---------- Click to fade ---------- */
const ray=new THREE.Raycaster(), mouse=new THREE.Vector2();
addEventListener('pointerdown', (e)=>{
  mouse.x =  (e.clientX/innerWidth)*2 - 1;
  mouse.y = -(e.clientY/innerHeight)*2 + 1;
  ray.setFromCamera(mouse,camera);
  const meshes=[]; world.traverse(o=>{ if(o.userData?.isFish) o.traverse(c=>{ if(c.isMesh) meshes.push(c); }); });
  const hit = ray.intersectObjects(meshes,true)[0];
  if(hit){
    let root=hit.object; while(root.parent && !root.userData?.isFish) root=root.parent;
    const fish = FISH.find(f=>f.group===root); fish?.triggerFade();
  }
});

/* ---------- Subtle, natural look-around (3) ---------- */
let mouseX=0;
const panRange=1.0;                 // lateral shift
const yawRange=THREE.MathUtils.degToRad(7); // gentle yaw
const bowRange=0.5;                 // slight forward bow for curvature

addEventListener('pointermove', (e)=>{
  const nx = (e.clientX / innerWidth) * 2 - 1;   // -1..1
  mouseX = THREE.MathUtils.clamp(nx, -1, 1);
});

addEventListener('resize', ()=>{
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});

/* ---------- Animate ---------- */
let last=performance.now();
function tick(now){
  const dt=Math.min((now-last)/1000,0.05); last=now; const t=now*0.001;

  // Move world: RIGHT → positive yaw/shift, LEFT → negative (natural)
  const targetX   = mouseX * panRange;
  const targetYaw = mouseX * yawRange;
  const targetZ   = -Math.abs(mouseX) * bowRange; // slight outward curve (bows toward viewer edges)

  world.position.x = THREE.MathUtils.lerp(world.position.x, targetX, 0.08);
  world.rotation.y = THREE.MathUtils.lerp(world.rotation.y, targetYaw, 0.08);
  world.position.z = THREE.MathUtils.lerp(world.position.z, targetZ, 0.08);

  for(const f of FISH) f.update(dt,t);
  renderer.render(scene,camera);
  requestAnimationFrame(tick);
}
requestAnimationFrame(tick);
</script>
</body>
</html>
